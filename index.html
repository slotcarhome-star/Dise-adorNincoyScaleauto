<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Slot Track Manager - Ninco & Scaleauto</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "three": "https://esm.sh/three@0.161.0",
            "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?external=react,react-dom,three",
            "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber",
            "lucide-react": "https://esm.sh/lucide-react@0.344.0?external=react",
            "three/examples/jsm/loaders/OBJLoader": "https://esm.sh/three@0.161.0/examples/jsm/loaders/OBJLoader.js",
            "three/examples/jsm/loaders/MTLLoader": "https://esm.sh/three@0.161.0/examples/jsm/loaders/MTLLoader.js",
            "idb-keyval": "https://esm.sh/idb-keyval@6.2.1"
        }
    }
    </script>

    <style>
        html, body { height: 100dvh; width: 100vw; margin: 0; padding: 0; overflow: hidden; background-color: #020202; color: #e0e0e0; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; touch-action: none; position: fixed; inset: 0; overscroll-behavior: none; }
        .app-container { display: flex; flex-direction: row; height: 100%; width: 100%; overflow: hidden; position: relative; }
        #root { height: 100%; width: 100%; display: flex; flex-direction: column; }
        
        /* SIDEBAR UNIFICADO */
        .sidebar { width: 360px; background: #050505; border-right: 1px solid #1a1a1a; display: flex; flex-direction: column; overflow-y: auto; flex-shrink: 0; z-index: 100; padding-bottom: env(safe-area-inset-bottom); box-shadow: 10px 0 40px rgba(0, 255, 0, 0.05); }
        .sidebar-header { padding: 20px 15px; background: #000; border-bottom: 1px solid #111; text-align: center; }
        .main-title-neon { color: #39ff14; font-family: 'Arial Black', sans-serif; font-weight: 900; text-transform: uppercase; letter-spacing: 1px; font-size: 18px; line-height: 1.2; text-shadow: 0 0 5px #39ff14, 0 0 15px rgba(57, 255, 20, 0.8), 0 0 30px rgba(57, 255, 20, 0.4); }
        .sidebar-content { flex: 1; padding: 15px; display: flex; flex-direction: column; gap: 20px; overflow-y: auto; }
        .sidebar-section { display: flex; flex-direction: column; gap: 10px; border-bottom: 1px solid #1a1a1a; padding-bottom: 15px; }
        .sidebar-section-title { font-size: 11px; font-weight: 900; color: #39ff14; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 5px; text-shadow: 0 0 8px #39ff14, 0 0 15px rgba(57, 255, 20, 0.6); }

        .canvas-area { flex: 1; position: relative; background: #050505; height: 100%; min-width: 0; }
        .btn-grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .btn-grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
        .btn-grid-4 { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 6px; }

        .ninco-header-mini { color: white; font-weight: 900; font-size: 22px; text-transform: uppercase; letter-spacing: -0.5px; text-shadow: 0 0 10px rgba(255,255,255,0.4); }
        .ninco-header-mini.ninco { color: #ff3333; text-shadow: 0 0 15px #ff0000; }
        .ninco-header-mini.scaleauto { color: #ffaa00; text-shadow: 0 0 15px #ff9900; }
        
        .tab-btn { padding: 12px; text-align: center; font-weight: 800; font-size: 11px; text-transform: uppercase; color: #888; cursor: pointer; transition: all 0.3s ease; background: #080808; border-radius: 8px; display: flex; align-items: center; justify-content: center; gap: 8px; border: 1px solid #222; letter-spacing: 1px; box-shadow: 0 0 5px rgba(57, 255, 20, 0.1); }
        .tab-btn:hover { color: #39ff14; border-color: #39ff14; box-shadow: 0 0 20px rgba(57, 255, 20, 0.5); text-shadow: 0 0 8px #39ff14; }
        .tab-btn.active { color: #000; background: #39ff14; border-color: #39ff14; box-shadow: 0 0 30px rgba(57, 255, 20, 0.7); font-weight: 900; }
        
        .btn-tile { position: relative; display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 8px; background-color: #080808; border: 1px solid #333; transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94); height: 55px; cursor: pointer; user-select: none; color: #888; overflow: hidden; box-shadow: 0 0 8px rgba(57, 255, 20, 0.15); }
        .btn-tile:hover { background-color: #051505; border-color: #39ff14; color: #39ff14; transform: translateY(-2px); box-shadow: 0 0 20px rgba(57, 255, 20, 0.6), inset 0 0 15px rgba(57, 255, 20, 0.2); text-shadow: 0 0 8px #39ff14; }
        .btn-tile:active { transform: scale(0.96); box-shadow: 0 0 10px rgba(57, 255, 20, 0.8); }
        .btn-tile.active-tool { border-color: #ff9900; color: #ff9900; background: #1a0a00; box-shadow: 0 0 25px rgba(255, 153, 0, 0.6), inset 0 0 15px rgba(255, 153, 0, 0.2); text-shadow: 0 0 10px #ff9900; }
        .btn-tile.btn-danger:hover { border-color: #ff003c; color: #ff003c; box-shadow: 0 0 25px rgba(255, 0, 60, 0.6); text-shadow: 0 0 10px #ff003c; background-color: #1a0005; }
        .btn-label { font-size: 8px; font-weight: 900; text-transform: uppercase; margin-top: 4px; color: inherit; letter-spacing: 1px; text-shadow: 0 0 2px currentColor; }
        
        .icon-curve, .icon-straight, .icon-cross, .icon-power { filter: drop-shadow(0 0 3px currentColor); }
        .icon-curve { width: 24px; height: 24px; border-top: 4px solid currentColor; border-right: 4px solid currentColor; border-radius: 0 100% 0 0; margin-top: 5px; margin-right: 5px; box-sizing: border-box; opacity: 1; }
        .icon-straight { width: 4px; height: 20px; border-radius: 1px; background: currentColor; transform: rotate(90deg); opacity: 1; }
        .icon-cross { position: relative; width: 14px; height: 22px; }
        .icon-cross::before, .icon-cross::after { content:''; position: absolute; width: 3px; height: 22px; background: currentColor; left: 5px; }
        .icon-cross::before { transform: rotate(15deg); } .icon-cross::after { transform: rotate(-15deg); }
        .icon-power { width: 8px; height: 18px; background: transparent; border-radius: 1px; border: 2px solid currentColor; opacity: 1; }
        
        .report-view { position: absolute; inset: 0; background: white; z-index: 200; overflow-y: auto; display: flex; flex-direction: column; font-family: Arial, Helvetica, sans-serif !important; }
        .report-header { background: #cc0000; color: white; padding: 15px; text-align: center; font-weight: 900; font-size: 28px; letter-spacing: -1px; text-transform: uppercase; border-bottom: 4px solid #990000; flex-shrink: 0; }
        .report-content { width: 100%; max-width: 1000px; margin: 0 auto; display: flex; flex-direction: column; flex: 1; padding: 10px; gap: 10px; }
        .inv-table { width: 100%; border-collapse: collapse; font-size: 14px; margin-bottom: 0; font-family: Arial, Helvetica, sans-serif; }
        .inv-table th { background: #e5e7eb; padding: 8px; text-align: left; border-bottom: 2px solid #666; text-transform: uppercase; font-size: 12px; color: #111; font-weight: 900; }
        .inv-table td { padding: 6px 8px; border-bottom: 1px solid #ddd; color: #333; }
        .inv-table tr:nth-child(even) { background: #f3f4f6; }
        .snapshot-wrapper { display: flex; justify-content: center; width: 100%; margin-bottom: 10px; }
        .snapshot-container { border: 4px solid #16a34a; padding: 2px; background: #fff; display: inline-block; border-radius: 4px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
        .snapshot-img { max-width: 100%; height: auto; max-height: 50vh; display: block; }

        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #ffffff; border: 2px solid #ef4444; cursor: pointer; margin-top: -6px; box-shadow: 0 1px 3px rgba(0,0,0,0.4); transition: transform 0.1s; }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.1); }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #4b5563; border-radius: 2px; }
        
        .touch-controls { position: fixed; top: 50%; right: 20px; transform: translateY(-50%); bottom: auto; display: flex; flex-direction: column; gap: 15px; align-items: flex-end; z-index: 1000; pointer-events: auto; }
        .touch-btn { width: 55px; height: 55px; border-radius: 50%; background: #000; border: 1px solid #333; color: #888; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 15px rgba(57, 255, 20, 0.3); cursor: pointer; transition: all 0.2s; }
        .touch-btn:hover { border-color: #39ff14; color: #39ff14; box-shadow: 0 0 25px rgba(57, 255, 20, 0.6); }
        .touch-btn:active { transform: scale(0.9); background: #39ff14; color: #000; box-shadow: 0 0 35px #39ff14; }
        .touch-pad-btn { width: 50px; height: 50px; background: #000; border: 1px solid #333; border-radius: 12px; color: #888; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 15px rgba(57, 255, 20, 0.3); transition: all 0.2s; }
        .touch-pad-btn:hover { border-color: #39ff14; color: #39ff14; box-shadow: 0 0 20px rgba(57, 255, 20, 0.5); }
        .touch-pad-btn:active { background: #1a1a1a; border-color: #ff9900; color: #ff9900; transform: scale(0.95); box-shadow: 0 0 25px rgba(255, 153, 0, 0.6); }

        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        .neon-title-blur { color: #ffffff; text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #ffaaaa, 0 0 40px #ff5555, 0 0 55px #ff0000, 0 0 75px #ff0000; font-weight: 900; letter-spacing: 3px; }
        .neon-panel-full { border: 2px solid #06b6d4; box-shadow: 0 0 5px #06b6d4, 0 0 20px rgba(6, 182, 212, 0.4), inset 0 0 30px rgba(6, 182, 212, 0.15); background: rgba(10, 10, 15, 0.9); backdrop-filter: blur(10px); }
        @keyframes slide-up { from { transform: translateY(100%); } to { transform: translateY(0); } }
        .animate-slide-up { animation: slide-up 0.3s ease-out forwards; }
        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
        @keyframes fade-in { from { opacity: 0; } to { opacity: 1; } }
        .animate-fade-in { animation: fade-in 0.2s ease-out forwards; }
        #error-overlay { display: none; position: fixed; inset: 0; background: #0f0f13; color: #ef4444; z-index: 9999; padding: 20px; font-family: monospace; overflow: auto; }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #000; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #39ff14; }

        @media print {
            .sidebar, .touch-controls, .no-print { display: none !important; }
            html, body, #root, .app-container { position: static !important; overflow: visible !important; height: auto !important; display: block !important; }
            .report-view { position: static; display: block; height: auto; overflow: visible; z-index: auto; width: 100%; }
            .report-content { padding: 0; margin: 0; max-width: 100%; }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <div id="error-overlay">
        <h2 style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">Error de Inicio</h2>
        <p>Hubo un problema al cargar la aplicación. Esto suele ocurrir si la red bloquea las librerías CDN.</p>
        <pre id="error-message" style="background: #1e1e1e; padding: 10px; border-radius: 5px; margin-top: 10px; color: #f87171; white-space: pre-wrap;"></pre>
    </div>

    <script>
        window.onerror = function(message, source, lineno, colno, error) {
            const overlay = document.getElementById('error-overlay');
            const msgBox = document.getElementById('error-message');
            overlay.style.display = 'block';
            msgBox.textContent = `${message}\n\nEn: ${source}:${lineno}:${colno}`;
            console.error(error);
        };
    </script>

    <script type="text/babel" data-type="module">
        import React, { useState, useMemo, useRef, useEffect, useCallback, Suspense } from 'react';
        import { createRoot } from 'react-dom/client';
        import { Canvas, useThree, useFrame, useLoader } from '@react-three/fiber';
        import { OrbitControls, PerspectiveCamera, Environment, Center, Line, Text, Grid, Stage } from '@react-three/drei';
        import * as THREE from 'three';
        import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader';
        import { MTLLoader } from 'three/examples/jsm/loaders/MTLLoader';
        import { get, set } from 'idb-keyval'; 
        import { 
            Trash2, Undo2, ArrowLeftRight, RotateCcw, Zap, Ruler, Lock, Unlock, Move, 
            RotateCw, Scan, FileText, Printer, ArrowLeft, Droplet, FileDown, Home, 
            CopyPlus, Plus, CarFront, Play, Pause, Settings2, Gauge, AlertTriangle, 
            Flag, Timer, Trophy, Check, Battery, Disc, PenTool, LayoutTemplate, 
            ZoomIn, ZoomOut, ArrowUp, ArrowDown, ArrowRight, X, Minus, Weight,
            Bot, User, Activity, StopCircle, RefreshCw, Clock, Save, FolderOpen,
            Move3d, MousePointer2, PlayCircle, StopCircle as StopIcon, Truck, History, Upload, FileBox,
            Database, TreePine, Trees, BoxSelect, Eye, Image as ImageIcon,
            Layers, Edit
        } from 'lucide-react';

        // --- SISTEMAS DE PISTA ---
        const TRACK_SYSTEMS = {
            ninco: { id: 'ninco', name: 'NINCO', width: 18, laneSpacing: 9, railOffset: 4.5, railGap: 0.25, color: '#1a1a1a', gripFactor: 1.0, headerClass: 'ninco-header', r1: 24.137, speedScale: 1.0 },
            scaleauto: { id: 'scaleauto', name: 'SCALEAUTO', width: 20, laneSpacing: 10, railOffset: 5.0, railGap: 0.3, color: '#64748b', gripFactor: 0.8, headerClass: 'ninco-header scaleauto-header', r1: 26.0, speedScale: 1.1 }
        };

        const MAGNET_FORCE = 25.0; 
        const PRESET_CARS = [
            { id: 'gt3_red', name: 'GT3 Rosso', type: 'STD', color: '#dc2626', specs: { offset: {x:0, y:0, z:0}, rotation: {y:0, z:0, x:0} }, description: 'Competición' },
            { id: 'gt3_blue', name: 'GT3 Blu', type: 'STD', color: '#2563eb', specs: { offset: {x:0, y:0, z:0}, rotation: {y:0, z:0, x:0} }, description: 'Equipo Oficial' },
            { id: 'lmp_yellow', name: 'LMP1 Speed', type: 'STD', color: '#eab308', specs: { offset: {x:0, y:0, z:0}, rotation: {y:0, z:0, x:0} }, description: 'Resistencia' },
            { id: 'rally_green', name: 'Rally X', type: 'STD', color: '#16a34a', specs: { offset: {x:0, y:0, z:0}, rotation: {y:0, z:0, x:0} }, description: 'Off-road' },
            { id: 'classic_white', name: 'Classic 911', type: 'STD', color: '#e2e8f0', specs: { offset: {x:0, y:0, z:0}, rotation: {y:0, z:0, x:0} }, description: 'Clásico' },
            { id: 'truck_black', name: 'Thunder Truck', type: 'TRUCK', color: '#1a1a1a', specs: { offset: {x:0, y:0.5, z:0}, rotation: {y:0, z:0, x:0} }, description: 'Camión' },
            { id: 'premium_1', name: 'Black Widow', type: 'STD', color: '#000000', specs: { offset: {x:0, y:0, z:0}, rotation: {y:0, z:0, x:0} }, description: 'Edición Limitada' },
            { id: 'premium_2', name: 'Gold Racer', type: 'STD', color: '#FFD700', specs: { offset: {x:0, y:0, z:0}, rotation: {y:0, z:0, x:0} }, description: 'Campeón Dorado' },
            { id: 'premium_3', name: 'Neon Night', type: 'STD', color: '#39ff14', specs: { offset: {x:0, y:0, z:0}, rotation: {y:0, z:0, x:0} }, description: 'Glow Series' },
            { id: 'premium_4', name: 'Cyber Truck', type: 'TRUCK', color: '#C0C0C0', specs: { offset: {x:0, y:0.5, z:0}, rotation: {y:0, z:0, x:0} }, description: 'Futurista' },
            { id: 'premium_5', name: 'Vintage 50s', type: 'STD', color: '#8B4513', specs: { offset: {x:0, y:0, z:0}, rotation: {y:0, z:0, x:0} }, description: 'Coleccionista' }
        ];
        const BASE_DECOS = [{ id: 'cube', name: 'Caja Test', type: 'BASIC_CUBE' }];
        const INITIAL_MOTORS = [{ id: 'nc8', name: 'NC-8 Thruster', rpm: 16000, torque: 0.8, color: '#fbbf24' }, { id: 'nc5', name: 'NC-5 Speeder', rpm: 20000, torque: 1.0, color: '#ef4444' }, { id: 'nc6', name: 'NC-6 Crusher', rpm: 23500, torque: 1.2, color: '#a855f7' }, { id: 'nc10', name: 'NC-10 Exceeder', rpm: 26000, torque: 1.4, color: '#3b82f6' }];
        const INITIAL_TIRES = [{ id: 'soft', name: 'Blandos', grip: 1.25, color: '#f87171', label: 'SOFT' }, { id: 'med',  name: 'Medios',  grip: 1.0,  color: '#facc15', label: 'MED' }, { id: 'hard', name: 'Duros',   grip: 0.85, color: '#94a3b8', label: 'HARD' }];
        const VOLTAGES = [12, 14];
        const LAP_OPTIONS = [10, 20, 30, 40, 50, Infinity];

        const getPieces = (system) => {
            const { width, r1, railOffset } = system;
            const halfW = width / 2;
            const R1_VAL = r1 - halfW;
            const R2_VAL = (r1 + width) - halfW;
            const R3_VAL = (r1 + width * 2) - halfW;
            const R4_VAL = (r1 + width * 3) - halfW;
            const R5_VAL = (r1 + width * 4) - halfW;
            return {
                'STD':  { id:'STD',  label:'Recta 40cm', type:'STRAIGHT', len:40 },
                'CONEX':{ id:'CONEX', label:'Conexiones', type:'STRAIGHT', len:40, isPower: true },
                'HALF': { id:'HALF', label:'Media 20cm', type:'STRAIGHT', len:20 },
                'QTR':  { id:'QTR',  label:'Cuarto 10cm', type:'STRAIGHT', len:10 },
                'XO':   { id:'XO',   label:'Cruce', type:'STRAIGHT', len:40, isCross: true },
                'R1':   { id:'R1',  label:'Curva R1', type:'CURVE', r:R1_VAL, ang:45,    col:'#ef4444' }, 
                'R2':   { id:'R2',  label:'Curva R2', type:'CURVE', r:R2_VAL, ang:45,    col:'#22c55e' }, 
                'R3':   { id:'R3',  label:'Curva R3', type:'CURVE', r:R3_VAL, ang:22.5,  col:'#eab308' }, 
                'R4':   { id:'R4',  label:'Curva R4', type:'CURVE', r:R4_VAL, ang:22.5,  col:'#3b82f6' }, 
                'R5':   { id:'R5',  label:'Curva R5', type:'CURVE', r:R5_VAL, ang:11.25, col:'#6366f1' }, 
                'R1H':  { id:'R1H', label:'Media R1/2', type:'CURVE', r:R1_VAL, ang:22.5,  col:'#ef4444', isHalf:true },
                'R2H':  { id:'R2H', label:'Media R2/2', type:'CURVE', r:R2_VAL, ang:22.5,  col:'#22c55e', isHalf:true },
            };
        };

        const MotorIcon = ({ color }) => (<svg width="40" height="40" viewBox="0 0 100 100" className="opacity-90"><rect x="20" y="25" width="60" height="50" rx="5" fill="#334155" stroke={color} strokeWidth="3" /><rect x="15" y="35" width="5" height="30" fill="#94a3b8" /><rect x="80" y="35" width="5" height="30" fill="#94a3b8" /><rect x="90" y="45" width="10" height="10" fill="#cbd5e1" /><path d="M40 25 L40 75 M60 25 L60 75" stroke="#475569" strokeWidth="2" /><text x="50" y="55" textAnchor="middle" fill={color} fontSize="14" fontWeight="bold">NC</text></svg>);
        const TireIcon = ({ color, label }) => (<svg width="40" height="40" viewBox="0 0 100 100" className="opacity-90"><circle cx="50" cy="50" r="40" fill="#1a1a1a" stroke={color} strokeWidth="3" /><circle cx="50" cy="50" r="25" fill="#333" stroke="#555" strokeWidth="1" /><path d="M50 10 L50 30 M50 70 L50 90 M90 50 L70 50 M30 50 L10 50" stroke="#222" strokeWidth="4" /><path d="M22 22 L36 36 M78 22 L64 36 M78 78 L64 64 M22 78 L36 64" stroke="#222" strokeWidth="4" /><text x="50" y="54" textAnchor="middle" fill={color} fontSize="12" fontWeight="bold">{label}</text></svg>);

        const FinishLine = ({ width }) => {
            const rows = 2; const size = 1.8; const cols = Math.floor((width - 1) / size); const startZ = -(cols * size) / 2; const TRACK_H = 0.6;
            const squares = useMemo(() => { const els = []; for(let r=0; r<rows; r++) { for(let c=0; c<cols; c++) { const isWhite = (r + c) % 2 === 0; els.push(<mesh key={`${r}-${c}`} position={[r * size, 0, startZ + c * size + size/2]} rotation={[-Math.PI/2, 0, 0]}><planeGeometry args={[size, size]} /><meshBasicMaterial color={isWhite ? '#ffffff' : '#111111'} /></mesh>); } } return els; }, [width, size, cols, startZ, rows]);
            return (<group position={[2, TRACK_H + 0.02, 0]}>{squares}<mesh position={[-0.2, 0, 0]} rotation={[-Math.PI/2, 0, 0]}><planeGeometry args={[0.2, width]} /><meshBasicMaterial color="white" /></mesh><mesh position={[rows * size + 0.2, 0, 0]} rotation={[-Math.PI/2, 0, 0]}><planeGeometry args={[0.2, width]} /><meshBasicMaterial color="white" /></mesh><Text position={[rows * size + 3.5, 0, 0]} rotation={[-Math.PI/2, 0, -Math.PI/2]} fontSize={2.5} color="white" fontWeight="bold" letterSpacing={0.1}>META</Text><Text position={[-3.5, 0, 0]} rotation={[-Math.PI/2, 0, Math.PI/2]} fontSize={2.5} color="white" fontWeight="bold" letterSpacing={0.1}>META</Text></group>);
        };

        const createStraightShape = (len, width) => { const s = new THREE.Shape(); s.moveTo(0,-width/2); s.lineTo(len,-width/2); s.lineTo(len,width/2); s.lineTo(0,width/2); return s; };
        const createCurveShape = (r, deg, isLeft, width) => { const s = new THREE.Shape(); const inner = r - width/2; const outer = r + width/2; const start = isLeft ? -Math.PI/2 : Math.PI/2; const rad = (deg * Math.PI)/180; const end = isLeft ? start + rad : start - rad; s.absarc(0,0, outer, start, end, !isLeft); s.lineTo(Math.cos(end)*inner, Math.sin(end)*inner); s.absarc(0,0, inner, end, start, isLeft); return s; };

        const Wheel = ({ pos, radius = 1.1, width = 1.0, spokes = false, color = "#1a1a1a", rimColor = "#e2e8f0" }) => ( <group position={pos}> <mesh rotation={[Math.PI/2, 0, 0]} castShadow> <cylinderGeometry args={[radius, radius, width, 32]} /> <meshStandardMaterial color="#1a1a1a" roughness={0.9} /> </mesh> <mesh rotation={[Math.PI/2, 0, 0]} position={[0, 0, 0]}> <cylinderGeometry args={[radius * 0.65, radius * 0.65, width + 0.05, 16]} /> <meshStandardMaterial color={rimColor} metalness={0.8} roughness={0.2} /> </mesh> <mesh rotation={[Math.PI/2, 0, 0]} position={[0, 0, width/2 + 0.05]}> <cylinderGeometry args={[0.15, 0.15, 0.1, 6]} /> <meshStandardMaterial color={color} metalness={0.5} /> </mesh> </group> );
        const StandardCar = ({ color, rotationZ = 0, offsetY = 0, offsetZ = 0 }) => ( <group position={[0, 1.5 + offsetY, offsetZ]} rotation={[0, 0, rotationZ * Math.PI / 180]}> <mesh position={[0, 1.2, 0]} castShadow receiveShadow> <boxGeometry args={[13.5, 2.4, 6.0]} /> <meshStandardMaterial color={color} metalness={0.4} roughness={0.3} /> </mesh> <mesh position={[-1.5, 2.7, 0]} castShadow> <boxGeometry args={[6.0, 1.5, 4.8]} /> <meshStandardMaterial color="#111" metalness={0.8} /> </mesh> <Wheel pos={[4.5, 0, 3.1]} radius={2.1} width={1.2} /> <Wheel pos={[4.5, 0, -3.1]} radius={2.1} width={1.2} /> <Wheel pos={[-4.5, 0, 3.1]} radius={2.2} width={1.5} /> <Wheel pos={[-4.5, 0, -3.1]} radius={2.2} width={1.5} /> <mesh position={[-6.6, 3.0, 0]}><boxGeometry args={[1.5, 0.3, 6.0]} /><meshStandardMaterial color={color}/></mesh> </group> );
        const CustomCar = ({ objUrl, mtlUrl, texUrl, color, rotationZ = 0, rotationX = 0, offsetY = 0, offsetZ = 0, offsetX = 0 }) => { const [model, setModel] = useState(null); useEffect(() => { if (!objUrl) { setModel(null); return; } const loadModel = async () => { try { let materials = null; if (mtlUrl) { const mtlLoader = new MTLLoader(); materials = await mtlLoader.loadAsync(mtlUrl); materials.preload(); } const objLoader = new OBJLoader(); if (materials) { objLoader.setMaterials(materials); } const obj = await objLoader.loadAsync(objUrl); if (texUrl) { const textureLoader = new THREE.TextureLoader(); const texture = await textureLoader.loadAsync(texUrl); obj.traverse((child) => { if (child.isMesh) { child.material.map = texture; child.material.needsUpdate = true; } }); } const box = new THREE.Box3().setFromObject(obj); const size = new THREE.Vector3(); box.getSize(size); const TARGET_LENGTH = 13.5; const maxDim = Math.max(size.x, size.y, size.z); const scale = TARGET_LENGTH / maxDim; obj.scale.setScalar(scale); box.setFromObject(obj); const center = new THREE.Vector3(); box.getCenter(center); obj.position.x = -center.x; obj.position.z = -center.z; obj.position.y = -box.min.y; if (!mtlUrl && !texUrl) { obj.traverse((child) => { if (child.isMesh) { child.material.color.set(color); } }); } obj.rotation.y = -Math.PI / 2; setModel(obj); } catch (e) { console.error("Error loading custom model", e); setModel(null); } }; loadModel(); }, [objUrl, mtlUrl, texUrl, color]); if (!model) return <StandardCar color={color} rotationZ={rotationZ} offsetY={offsetY} offsetZ={offsetZ} />; return ( <group position={[offsetX, 0.5 + offsetY, offsetZ]} rotation={[rotationX * Math.PI / 180, 0, rotationZ * Math.PI / 180]}> <primitive object={model} castShadow receiveShadow /> </group> ); };
        const CarModel = ({ type, color = "#dc2626", customData, rotationZ, rotationX, offsetY, offsetZ, offsetX }) => { if (type === 'CUSTOM_OBJ' && customData?.obj) { return <CustomCar objUrl={customData.obj} mtlUrl={customData.mtl} texUrl={customData.tex} color={color} rotationZ={rotationZ} rotationX={rotationX} offsetY={offsetY} offsetZ={offsetZ} offsetX={offsetX} />; } return <StandardCar color={color} rotationZ={rotationZ} offsetY={offsetY} offsetZ={offsetZ} />; };

        const DecorationObject = ({ objUrl, mtlUrl }) => { const [model, setModel] = useState(null); useEffect(() => { if (!objUrl) { setModel(null); return; } const loadModel = async () => { try { let materials = null; if (mtlUrl) { const mtlLoader = new MTLLoader(); materials = await mtlLoader.loadAsync(mtlUrl); materials.preload(); } const objLoader = new OBJLoader(); if (materials) { objLoader.setMaterials(materials); } const obj = await objLoader.loadAsync(objUrl); const box = new THREE.Box3().setFromObject(obj); const size = new THREE.Vector3(); box.getSize(size); const maxDim = Math.max(size.x, size.y, size.z); const TARGET_SIZE = 12.0; if (maxDim > 30 || maxDim < 2) { const scaleFactor = TARGET_SIZE / maxDim; obj.scale.setScalar(scaleFactor); } box.setFromObject(obj); const center = new THREE.Vector3(); box.getCenter(center); obj.position.x -= center.x; obj.position.z -= center.z; obj.position.y -= (box.min.y); setModel(obj); } catch (e) { console.error("Error loading decoration model", e); setModel(null); } }; loadModel(); }, [objUrl, mtlUrl]); if (!model) return <mesh position={[0, 2.5, 0]}><boxGeometry args={[5, 5, 5]} /><meshStandardMaterial color="gray" /></mesh>; return <primitive object={model} castShadow receiveShadow />; };
        const DraggableDecoration = ({ data, modelInfo, isSelected, isDecoMode, onUpdate, onSelect }) => { const { camera, raycaster, gl } = useThree(); const [isDragging, setIsDragging] = useState(false); const dragPlane = useMemo(() => new THREE.Plane(new THREE.Vector3(0, 1, 0), 0), []); const intersectPoint = useMemo(() => new THREE.Vector3(), []); const handlePointerDown = (e) => { if (!isDecoMode) return; e.stopPropagation(); onSelect(data.instanceId); setIsDragging(true); gl.domElement.style.cursor = 'grabbing'; }; useEffect(() => { const handleMove = (e) => { if (!isDragging) return; const rect = gl.domElement.getBoundingClientRect(); const x = ((e.clientX - rect.left) / rect.width) * 2 - 1; const y = -((e.clientY - rect.top) / rect.height) * 2 + 1; raycaster.setFromCamera(new THREE.Vector2(x, y), camera); if (raycaster.ray.intersectPlane(dragPlane, intersectPoint)) { onUpdate(data.instanceId, 'position', [intersectPoint.x, 0, intersectPoint.z]); } }; const handleUp = () => { setIsDragging(false); gl.domElement.style.cursor = 'auto'; }; if (isDragging) { window.addEventListener('pointermove', handleMove); window.addEventListener('pointerup', handleUp); } return () => { window.removeEventListener('pointermove', handleMove); window.removeEventListener('pointerup', handleUp); }; }, [isDragging, camera, raycaster, gl, dragPlane, onUpdate, data.instanceId]); return ( <group position={data.position} rotation={new THREE.Euler(data.rotation[0], data.rotation[1], data.rotation[2])} scale={[data.scale, data.scale, data.scale]} onPointerDown={handlePointerDown} onPointerOver={(e) => { if(isDecoMode) { e.stopPropagation(); gl.domElement.style.cursor = 'move'; } }} onPointerOut={(e) => { if(isDecoMode) gl.domElement.style.cursor = 'auto'; }} > <DecorationObject objUrl={modelInfo?.customData?.obj} mtlUrl={modelInfo?.customData?.mtl} /> {isSelected && isDecoMode && ( <mesh position={[0, 6, 0]}> <boxGeometry args={[1, 14, 1]} /> <meshBasicMaterial color="yellow" wireframe /> </mesh> )} {isSelected && isDecoMode && ( <mesh position={[0, 0.1, 0]} rotation={[-Math.PI/2, 0, 0]}> <ringGeometry args={[5, 6, 32]} /> <meshBasicMaterial color="yellow" opacity={0.6} transparent /> </mesh> )} </group> ); };

        const createTrackSpline = (chain, selectedLane, systemPieces, systemSpecs) => { const points = []; const segmentMap = []; const offset = systemSpecs.railOffset; let currentLaneOffset = selectedLane === 1 ? offset : -offset; const numCrosses = chain.filter(s => systemPieces[s.pId] && systemPieces[s.pId].isCross).length; const iterations = (numCrosses % 2 !== 0) ? 2 : 1; const SUBDIVISIONS_PER_UNIT = 2.0; const TRACK_H = 0.6; let isBroken = false; for (let loop = 0; loop < iterations; loop++) { if (isBroken) break; for (const seg of chain) { if (isBroken) break; const def = systemPieces[seg.pId]; if (!def) continue; let numSteps = 5; let segLength = 0; if (def.len) { numSteps = Math.max(10, Math.ceil(def.len * SUBDIVISIONS_PER_UNIT)); segLength = def.len; } else if (def.ang) { const arcLen = (def.ang * Math.PI / 180) * def.r; numSteps = Math.max(10, Math.ceil(arcLen * SUBDIVISIONS_PER_UNIT)); segLength = arcLen; } const isCurve = def.type === 'CURVE'; const radius = isCurve ? def.r : Infinity; const label = def.label; const dir = seg.dir; const startOffset = currentLaneOffset; const endOffset = def.isCross ? -currentLaneOffset : currentLaneOffset; for (let i = 0; i <= numSteps; i++) { const t = i / numSteps; const localPos = new THREE.Vector3(); if (def.type === 'STRAIGHT') { if (def.isCross) { const blend = (1 - Math.cos(t * Math.PI)) * 0.5; const currentZ = startOffset + (endOffset - startOffset) * blend; localPos.set(t * def.len, TRACK_H, currentZ); } else { localPos.set(t * def.len, TRACK_H, currentLaneOffset); } } else { const isLeft = seg.dir === 1; const Reff = isLeft ? (def.r + currentLaneOffset) : (def.r - currentLaneOffset); const angleRad = t * (def.ang * Math.PI / 180); if (isLeft) { const theta = -Math.PI/2 + angleRad; localPos.set(Reff * Math.cos(theta), TRACK_H, -(Reff * Math.sin(theta) + def.r)); } else { const theta = Math.PI/2 - angleRad; localPos.set(Reff * Math.cos(theta), TRACK_H, -(Reff * Math.sin(theta) - def.r)); } } localPos.applyMatrix4(seg.mat); if (points.length > 0 && i === 0) { const lastP = points[points.length - 1]; if (localPos.distanceTo(lastP) > 5.0) { isBroken = true; break; } } if (points.length === 0 || points[points.length-1].distanceTo(localPos) > 0.001) { points.push(localPos); } } if (!isBroken) { segmentMap.push({ length: segLength, isCurve, radius, label, dir }); if (def.isCross) { currentLaneOffset = endOffset; } } } } if (points.length < 2) return null; const closed = points.length > 2 && points[0].distanceTo(points[points.length-1]) < 20; const curve = new THREE.CatmullRomCurve3(points, closed, 'centripetal', 0.1); const splineLength = curve.getLength(); let accumulated = 0; const normalizedMap = segmentMap.map(s => { const startT = accumulated / splineLength; accumulated += s.length; const endT = accumulated / splineLength; return { ...s, startT, endT }; }); return { curve, totalLength: splineLength, closed, points, map: normalizedMap }; };
        const AnimatedCar = ({ tracks, throttle, isPlaying, isPaused, selectedLane = 1, onLap, motor, tires, voltage, weight, onDerail, driveMode, onTelemetry, totalLaps, systemId, resetToken, carModelId, carType, customData, modelRotation, modelRotationZ, modelRotationX, offsetY, offsetZ, offsetX }) => { 
            const carRef = useRef(); 
            const [velocity, setVelocity] = useState(0); 
            const [progress, setProgress] = useState(0); 
            const [derailed, setDerailed] = useState(false); 
            const [derailVector, setDerailVector] = useState(new THREE.Vector3()); 
            const lapTimeRef = useRef(0); 
            const telemetryTick = useRef(0); 
            const systemSpecs = TRACK_SYSTEMS[systemId]; 
            const systemPieces = useMemo(() => getPieces(systemSpecs), [systemId]); 
            const renderType = carType || (carModelId.startsWith('custom-') ? 'CUSTOM_OBJ' : 'STD'); 
            
            const trackIndex = Math.floor((selectedLane - 1) / 2);
            const laneOnTrack = ((selectedLane - 1) % 2) + 1; 
            const activeChain = tracks[trackIndex] || tracks[0] || [];

            useEffect(() => { setVelocity(0); setProgress(0); setDerailed(false); lapTimeRef.current = 0; }, [tracks, selectedLane, systemId, resetToken]); 
            const trackSpline = useMemo(() => { if (activeChain.length === 0) return null; return createTrackSpline(activeChain, laneOnTrack, systemPieces, systemSpecs); }, [activeChain, laneOnTrack, systemPieces, systemSpecs]); 
            const splinePoints = useMemo(() => { if (!trackSpline) return []; return trackSpline.curve.getPoints(trackSpline.totalLength * 2); }, [trackSpline]); 
            
            useFrame((state, delta) => { 
                if (!trackSpline || !carRef.current) return; 
                if (!isPlaying && !derailed && !isPaused) { setVelocity(0); return; } 
                if (isPaused) return; 
                
                if (derailed) { 
                    carRef.current.position.addScaledVector(derailVector, delta * 30); 
                    carRef.current.rotation.y += delta * 5; 
                    carRef.current.rotation.z += delta * 2; 
                    return; 
                } 
                
                const currentSegIdx = trackSpline.map.findIndex(s => progress >= s.startT && progress < s.endT); 
                const actualIdx = currentSegIdx !== -1 ? currentSegIdx : 0; 
                const currentSeg = trackSpline.map[actualIdx]; 
                
                const BASE_MAX_SPEED = 550; 
                const ACCEL_FACTOR = 200; 
                const BRAKE_FACTOR = 450; 
                const voltageFactor = voltage / 12; 
                const motorFactor = motor.rpm / 20000; 
                const carTopSpeed = BASE_MAX_SPEED * motorFactor * voltageFactor; 
                const accelRate = motor.torque * voltageFactor * ACCEL_FACTOR; 
                const brakeRate = motor.torque * BRAKE_FACTOR; 
                
                const realRadius = currentSeg.isCurve ? currentSeg.radius : 9999; 
                const systemGrip = systemSpecs.gripFactor; 
                const tireGrip = tires.grip; 
                const magnetGrip = (MAGNET_FORCE / 25) * 0.6; 
                const weightPenalty = (weight - 80) * 0.005; 
                const totalGripFactor = (systemGrip + tireGrip * 0.5 + magnetGrip - weightPenalty); 
                const safeCornerSpeed = Math.sqrt(realRadius * 1500 * totalGripFactor); 
                
                let currentThrottle = throttle; 
                if (driveMode === 'ai') { 
                    const nextIdx = (actualIdx + 1) % trackSpline.map.length; 
                    const nextSeg = trackSpline.map[nextIdx]; 
                    let speedLimit = safeCornerSpeed; 
                    if (nextSeg.isCurve) { 
                        const nextRadius = nextSeg.radius; 
                        const nextCornerLimit = Math.sqrt(nextRadius * 1500 * totalGripFactor); 
                        if (velocity > nextCornerLimit * 0.95) { 
                            const segmentProgress = (progress - currentSeg.startT) / (currentSeg.endT - currentSeg.startT); 
                            if (segmentProgress > 0.70) { speedLimit = nextCornerLimit * 0.95; } 
                        } 
                    } 
                    if (velocity > speedLimit) currentThrottle = 0; 
                    else currentThrottle = 0.9 + (motorFactor * 0.05); 
                } 
                
                const targetSpeed = currentThrottle * carTopSpeed; 
                let newVelocity = velocity; 
                if (targetSpeed > velocity) { 
                    newVelocity += accelRate * delta; 
                    if (newVelocity > targetSpeed) newVelocity = targetSpeed; 
                } else { 
                    newVelocity -= brakeRate * delta; 
                    if (newVelocity < targetSpeed) newVelocity = targetSpeed; 
                } 
                
                const realSpeedKmH = newVelocity * 0.036; 
                const limitRealSpeedKmH = safeCornerSpeed * 0.036; 
                
                telemetryTick.current += 1; 
                if (onTelemetry && telemetryTick.current > 10) { 
                    telemetryTick.current = 0; 
                    onTelemetry({ speed: realSpeedKmH, limit: limitRealSpeedKmH, section: currentSeg.label, throttle: currentThrottle, gForce: (newVelocity * newVelocity) / (realRadius * 980), gripLimit: (newVelocity / safeCornerSpeed) * 100 }); 
                } 
                
                const DERAIL_THRESHOLD = safeCornerSpeed * 1.15; 
                if (currentSeg.isCurve && newVelocity > DERAIL_THRESHOLD) { 
                    setDerailed(true); 
                    const tangent = trackSpline.curve.getTangentAt(progress).normalize(); 
                    const up = new THREE.Vector3(0, 1, 0); 
                    const normal = new THREE.Vector3().crossVectors(tangent, up).normalize(); 
                    const exitVec = tangent.clone().multiplyScalar(0.7).add(normal.multiplyScalar(0.5)); 
                    setDerailVector(exitVec); 
                    if(onDerail) onDerail(); 
                    setTimeout(() => { setDerailed(false); setVelocity(0); }, 2000); 
                    return; 
                } 
                
                setVelocity(newVelocity); 
                const VISUAL_SCALE = 1.0; 
                const moveDist = delta * newVelocity * VISUAL_SCALE; 
                const progressDelta = moveDist / trackSpline.totalLength; 
                
                lapTimeRef.current += delta; 
                let nextProgress = progress + progressDelta; 
                if (nextProgress >= 1) { 
                    if (trackSpline.closed) { 
                        nextProgress = nextProgress % 1; 
                        if (onLap) onLap(lapTimeRef.current); 
                        lapTimeRef.current = 0; 
                    } else { 
                        nextProgress = 0; 
                        setVelocity(0); 
                        if (onLap) onLap(lapTimeRef.current); 
                        lapTimeRef.current = 0; 
                    } 
                } 
                setProgress(nextProgress); 
                
                const point = trackSpline.curve.getPointAt(nextProgress); 
                carRef.current.position.copy(point); 
                const tangent = trackSpline.curve.getTangentAt(nextProgress).normalize(); 
                const baseQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1, 0, 0), tangent); 
                let driftAngle = 0; 
                if (currentSeg.isCurve) { 
                    const speedRatio = Math.min(1.2, newVelocity / safeCornerSpeed); 
                    if (speedRatio > 0.3) { 
                        const MAX_DRIFT = 35 * (Math.PI / 180); 
                        const intensity = Math.pow(speedRatio, 2.5); 
                        const direction = currentSeg.dir || 1; 
                        driftAngle = direction * intensity * MAX_DRIFT * 0.8; 
                    } 
                } 
                carRef.current.quaternion.copy(baseQuaternion); 
                carRef.current.rotateY(driftAngle); 
            }); 
            
            return ( 
                <group> 
                    {trackSpline && ( <Line points={splinePoints} color={laneOnTrack === 1 ? "cyan" : "orange"} lineWidth={1.5} position={[0, 0.7, 0]} opacity={0.6} transparent /> )} 
                    <group ref={carRef}> 
                        <group position={[-5.0, 0, 0]}> 
                            <group rotation={[0, modelRotation * Math.PI / 180, 0]}> 
                                <CarModel type={renderType} color={laneOnTrack === 1 ? "#ef4444" : "#3b82f6"} customData={customData} rotationZ={modelRotationZ} rotationX={modelRotationX} offsetY={offsetY} offsetZ={offsetZ} offsetX={offsetX} /> 
                            </group> 
                        </group> 
                        {derailed && (<Text position={[0, 4, 0]} fontSize={2} color="yellow" rotation={[0, Math.PI/2, 0]}>!</Text>)} 
                        {driveMode === 'ai' && (<Text position={[0, 5, 0]} fontSize={1.5} color="#3b82f6" rotation={[0, Math.PI/2, 0]}>AI</Text>)} 
                    </group> 
                </group> 
            ); 
        };
        class ErrorBoundary extends React.Component { constructor(props) { super(props); this.state = { hasError: false }; } static getDerivedStateFromError(error) { return { hasError: true }; } componentDidCatch(error, errorInfo) { console.error("Error cargando modelo:", error); } render() { if (this.state.hasError) { return this.props.fallback; } return this.props.children; } }
        const DraggableBoard = React.forwardRef(({ width, length, enabled, onBoardClick, isPlacingTree, isDecoMode }, ref) => { const { camera, raycaster, gl } = useThree(); const [isDragging, setIsDragging] = useState(false); const dragPlane = useMemo(() => new THREE.Plane(new THREE.Vector3(0, 1, 0), 0), []); const intersectPoint = useMemo(() => new THREE.Vector3(), []); const offset = useRef(new THREE.Vector3()); const boardGeometry = useMemo(() => new THREE.BoxGeometry(width, length, 1.2), [width, length]); const handlePointerDown = (e) => { if (isDecoMode) return; if (!enabled || !ref.current || isPlacingTree) return; e.stopPropagation(); offset.current.subVectors(ref.current.position, e.point); setIsDragging(true); gl.domElement.style.cursor = 'grabbing'; }; const handleClick = (e) => { if ((isPlacingTree || isDecoMode) && onBoardClick) { e.stopPropagation(); onBoardClick(e.point); } }; useEffect(() => { const handleMove = (e) => { if (!isDragging || !ref.current) return; const rect = gl.domElement.getBoundingClientRect(); const x = ((e.clientX - rect.left) / rect.width) * 2 - 1; const y = -((e.clientY - rect.top) / rect.height) * 2 + 1; raycaster.setFromCamera(new THREE.Vector2(x, y), camera); if (raycaster.ray.intersectPlane(dragPlane, intersectPoint)) { ref.current.position.x = intersectPoint.x + offset.current.x; ref.current.position.z = intersectPoint.z + offset.current.z; } }; const handleUp = () => { setIsDragging(false); if (gl.domElement) gl.domElement.style.cursor = 'auto'; }; if (isDragging) { window.addEventListener('pointermove', handleMove); window.addEventListener('pointerup', handleUp); } return () => { window.removeEventListener('pointermove', handleMove); window.removeEventListener('pointerup', handleUp); }; }, [isDragging, camera, raycaster, gl, dragPlane]); if (!width || !length) return null; const cursorStyle = (isPlacingTree || isDecoMode) ? 'crosshair' : (enabled ? 'grab' : 'auto'); return ( <mesh ref={ref} rotation={[-Math.PI / 2, 0, 0]} position={[0, -0.6, 0]} receiveShadow onPointerDown={handlePointerDown} onClick={handleClick} onPointerOver={() => { if(gl.domElement) gl.domElement.style.cursor = cursorStyle; }} onPointerOut={() => { if(gl.domElement) gl.domElement.style.cursor = 'auto'; }} geometry={boardGeometry} > <meshStandardMaterial color={enabled ? "#16a34a" : "#15803d"} roughness={1} /> <lineSegments position={[0,0,0.61]} rotation={[0,0,0]}> <edgesGeometry args={[boardGeometry]} /> <lineBasicMaterial color={enabled ? "#ffff00" : "#ffffff"} linewidth={2} opacity={0.3} transparent /> </lineSegments> <gridHelper args={[Math.max(width, length), Math.max(width, length)/10]} rotation={[Math.PI/2, 0, 0]} position={[0,0,0.61]} material-opacity={0.1} material-transparent /> </mesh> ); });
        const StartPieceHandler = ({ children, position, onPosChange, isSelected, enabled, dragEnabled, id }) => { const { camera, raycaster, gl } = useThree(); const [isDragging, setIsDragging] = useState(false); const plane = useMemo(() => new THREE.Plane(new THREE.Vector3(0, 1, 0), 0), []); const intersectPoint = useMemo(() => new THREE.Vector3(), []); const [hovered, setHovered] = useState(false); const handlePointerDown = (e) => { if (!dragEnabled) return; e.stopPropagation(); setIsDragging(true); if (gl.domElement) gl.domElement.style.cursor = 'grabbing'; }; useEffect(() => { const handleMove = (e) => { if (!isDragging || !dragEnabled) return; const rect = gl.domElement.getBoundingClientRect(); const x = ((e.clientX - rect.left) / rect.width) * 2 - 1; const y = -((e.clientY - rect.top) / rect.height) * 2 + 1; raycaster.setFromCamera(new THREE.Vector2(x, y), camera); if (raycaster.ray.intersectPlane(plane, intersectPoint)) { const snapX = Math.round(intersectPoint.x); const snapZ = Math.round(intersectPoint.z); onPosChange(id, new THREE.Vector3(snapX, 0, snapZ)); } }; const handleUp = () => { setIsDragging(false); if (gl.domElement) gl.domElement.style.cursor = 'auto'; }; if (isDragging) { window.addEventListener('pointermove', handleMove); window.addEventListener('pointerup', handleUp); } return () => { window.removeEventListener('pointermove', handleMove); window.removeEventListener('pointerup', handleUp); }; }, [isDragging, dragEnabled, camera, raycaster, gl, plane, onPosChange, id]); return ( <group position={position} > {children} {dragEnabled && ( <group position={[20, 15, 0]} onPointerDown={handlePointerDown} onPointerOver={() => { setHovered(true); gl.domElement.style.cursor = 'move'; }} onPointerOut={() => { setHovered(false); gl.domElement.style.cursor = 'auto'; }} > <mesh> <sphereGeometry args={[8, 32, 32]} /> <meshStandardMaterial color={hovered || isDragging ? "#facc15" : "#eab308"} transparent opacity={0.8} /> </mesh> <group scale={[2.5, 2.5, 2.5]} position={[0,0,0]}> <mesh position={[3, 0, 0]} rotation={[0, 0, -Math.PI/2]}> <coneGeometry args={[0.8, 2, 8]} /> <meshBasicMaterial color="white" /> </mesh> <mesh position={[-3, 0, 0]} rotation={[0, 0, Math.PI/2]}> <coneGeometry args={[0.8, 2, 8]} /> <meshBasicMaterial color="white" /> </mesh> <mesh position={[0, 0, 3]} rotation={[Math.PI/2, 0, 0]}> <coneGeometry args={[0.8, 2, 8]} /> <meshBasicMaterial color="white" /> </mesh> <mesh position={[0, 0, -3]} rotation={[-Math.PI/2, 0, 0]}> <coneGeometry args={[0.8, 2, 8]} /> <meshBasicMaterial color="white" /> </mesh> </group> <Text position={[0, 12, 0]} fontSize={6} color="yellow" anchorX="center" anchorY="middle" rotation={[-Math.PI/2, 0, 0]} fontWeight="bold" outlineWidth={0.2} outlineColor="black"> ARRASTRAR </Text> </group> )} {isSelected && enabled && !dragEnabled && ( <group position={[20, 5, 0]}> <Text fontSize={4} color="white" anchorX="center" anchorY="middle" rotation={[-Math.PI/2, 0, 0]}>SALIDA</Text> <mesh position={[0, -2, 0]} rotation={[-Math.PI/2, 0, 0]}><circleGeometry args={[8, 32]} /><meshBasicMaterial color="red" opacity={0.3} transparent /></mesh> </group> )} </group> ); };

        const TrackMesh = ({ def, isLeft, isSelected, onClick, systemSpecs, hasFence }) => {
            const { width, railOffset, railGap, color } = systemSpecs;
            const TRACK_H = 0.6;
            const geom = useMemo(() => { if (!def) return null; if (def.type === 'STRAIGHT') { const g = new THREE.ExtrudeGeometry(createStraightShape(def.len, width), {depth: TRACK_H, bevelEnabled:false}); g.rotateX(-Math.PI/2); return g; } else { const g = new THREE.ExtrudeGeometry(createCurveShape(def.r, def.ang, isLeft, width), {depth: TRACK_H, bevelEnabled:false, curveSegments:64}); const yOff = isLeft ? def.r : -def.r; g.translate(0, yOff, 0); g.rotateX(-Math.PI/2); return g; } }, [def, isLeft, width]);
            const fenceGeom = useMemo(() => { if (!def || def.type !== 'CURVE' || hasFence === false) return null; const fenceHeight = 2.5; const fenceThickness = 0.3; const outerRadius = def.r + width/2 + 0.5; const shape = new THREE.Shape(); const start = isLeft ? -Math.PI/2 : Math.PI/2; const rad = (def.ang * Math.PI)/180; const end = isLeft ? start + rad : start - rad; shape.absarc(0, 0, outerRadius + fenceThickness, start, end, !isLeft); shape.absarc(0, 0, outerRadius, end, start, isLeft); const g = new THREE.ExtrudeGeometry(shape, { depth: fenceHeight, bevelEnabled: false, curveSegments: 32 }); const yOff = isLeft ? def.r : -def.r; g.translate(0, yOff, 0); g.rotateX(-Math.PI/2); return g; }, [def, isLeft, width, hasFence]);
            const trackMat = useMemo(() => new THREE.MeshStandardMaterial({ color: systemSpecs.color, roughness: 0.7, metalness: 0.1 }), [systemSpecs.color]);
            const railMat = useMemo(() => new THREE.MeshStandardMaterial({ color: '#c0c0c0', metalness: 0.8, roughness: 0.3 }), []);
            const fenceMat = useMemo(() => { const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128; const ctx = canvas.getContext('2d'); ctx.fillStyle = '#64748b'; ctx.fillRect(0,0,128,128); ctx.fillStyle = '#94a3b8'; ctx.fillRect(0, 0, 128, 8); ctx.fillStyle = '#475569'; ctx.fillRect(0, 120, 128, 8); const tex = new THREE.CanvasTexture(canvas); return new THREE.MeshStandardMaterial({ map: tex, roughness: 0.6, metalness: 0.1 }); }, [def, systemSpecs]);
            const rails = useMemo(() => { if (!def) return null; if(def.type === 'STRAIGHT') { if (def.isCross) { const l_start = -railOffset; const l_end = railOffset; const H_RAIL = 0.05; const TANGENT_DIST = def.len * 0.35; const makeSCurve = (zStart, zEnd) => new THREE.CubicBezierCurve3(new THREE.Vector3(0, H_RAIL, zStart), new THREE.Vector3(TANGENT_DIST, H_RAIL, zStart), new THREE.Vector3(def.len - TANGENT_DIST, H_RAIL, zEnd), new THREE.Vector3(def.len, H_RAIL, zEnd)); const c1_L = makeSCurve(l_start - railGap, l_end - railGap); const c1_R = makeSCurve(l_start + railGap, l_end + railGap); const c2_L = makeSCurve(l_end - railGap, l_start - railGap); const c2_R = makeSCurve(l_end + railGap, l_start + railGap); return (<group position={[0, TRACK_H, 0]}><mesh geometry={new THREE.TubeGeometry(c1_L, 32, 0.08, 8, false)} material={railMat} /><mesh geometry={new THREE.TubeGeometry(c1_R, 32, 0.08, 8, false)} material={railMat} /><mesh geometry={new THREE.TubeGeometry(c2_L, 32, 0.08, 8, false)} material={railMat} /><mesh geometry={new THREE.TubeGeometry(c2_R, 32, 0.08, 8, false)} material={railMat} /></group>); } else { return (<group position={[0, TRACK_H+0.05, 0]}>{[-railOffset - railGap, -railOffset + railGap, railOffset - railGap, railOffset + railGap].map((off, i) => (<mesh key={i} position={[def.len/2, 0, off]} rotation={[-Math.PI/2,0,0]}><planeGeometry args={[def.len, 0.15]} /><primitive object={railMat} attach="material"/></mesh>))}</group>); } } else { const mkArc = (rOff) => { const s = new THREE.Shape(); const st = isLeft ? -Math.PI/2 : Math.PI/2; const rad = (def.ang * Math.PI)/180; const en = isLeft ? st + rad : st - rad; s.absarc(0,0, rOff + 0.075, st, en, !isLeft); s.absarc(0,0, rOff - 0.075, en, st, isLeft); const g = new THREE.ExtrudeGeometry(s, {depth:0.02, bevelEnabled:false, curveSegments:64}); g.translate(0, isLeft ? def.r : -def.r, 0); g.rotateX(-Math.PI/2); return g; }; return (<group position={[0, TRACK_H, 0]}>{ [def.r - railOffset - railGap, def.r - railOffset + railGap, def.r + railOffset - railGap, def.r + railOffset + railGap].map((off, i) => <mesh key={i} geometry={mkArc(off)} material={railMat} />)}</group>); } }, [def, isLeft, railMat, railOffset, railGap]);
            return ( <group onClick={onClick}> <mesh geometry={geom} receiveShadow castShadow material={trackMat}> {isSelected && ( <lineSegments position={[0, 0.1, 0]}> <edgesGeometry args={[geom]} /> <lineBasicMaterial color="#ff9900" linewidth={5} transparent opacity={0.8} /> </lineSegments> )} {def.isPower && (<group position={[def.len/2, 0, 0]}><mesh position={[0, TRACK_H+0.5, -(width/2 + 2)]}><boxGeometry args={[10, 1, 4]} /><meshStandardMaterial color="#dc2626" /></mesh><mesh position={[0, TRACK_H+1.1, -(width/2 + 2)]} rotation={[-Math.PI/2,0,0]}><planeGeometry args={[8, 3]} /><meshBasicMaterial color="#ef4444" /></mesh></group>)} {def.isHalf && (<mesh position={[0, TRACK_H+0.01, 0]} rotation={[-Math.PI/2,0,0]}><ringGeometry args={[def.r-0.5, def.r+0.5, 32, 1, isLeft?-Math.PI/2:Math.PI/2, (def.ang*Math.PI)/180 * (isLeft?1:-1)]} /><meshBasicMaterial color={def.col} opacity={0.5} transparent /></mesh>)} </mesh> {rails} <mesh position={[0, TRACK_H/2, 0]}><boxGeometry args={[0.2, TRACK_H, width-0.5]} /><meshBasicMaterial color="#000" /></mesh> {fenceGeom && <mesh geometry={fenceGeom} material={fenceMat} position={[0, 0, 0]} castShadow receiveShadow />} </group> );
        };

        const SceneManager = ({ appMode, viewMode, onCaptureReady, boardRef, boardSize, setViewMode }) => { const { camera, controls, gl, scene } = useThree(); useEffect(() => { if (viewMode === 'editor') { if (appMode === 'builder') { camera.position.set(0, 500, 0); camera.lookAt(0,0,0); camera.rotation.z = -Math.PI / 2; if(controls) { controls.target.set(0,0,0); controls.update(); } } else if (appMode === 'racer') { camera.position.set(0, 200, 300); if(controls) { controls.target.set(0,0,0); controls.update(); } } } }, [appMode, viewMode, camera, controls]); useEffect(() => { if (viewMode === 'capturing') { const oldBg = scene.background; scene.background = new THREE.Color('#ffffff'); const padding = 1.1; let targetX = 0; let targetZ = 0; let dimX = 200; let dimZ = 200; if (boardRef && boardRef.current) { targetX = boardRef.current.position.x; targetZ = boardRef.current.position.z; dimX = boardSize.width; dimZ = boardSize.length; } const vFOV = THREE.MathUtils.degToRad(camera.fov); const aspect = gl.domElement.clientWidth / gl.domElement.clientHeight; const finalHeight = Math.max((dimZ / 2) / Math.tan(vFOV / 2), (dimX / 2) / (Math.tan(vFOV / 2) * aspect)) * padding; camera.position.set(targetX, finalHeight, targetZ); camera.lookAt(targetX, 0, targetZ); camera.rotation.set(-Math.PI/2, 0, 0); camera.updateProjectionMatrix(); if (controls) controls.enabled = false; setTimeout(() => { gl.render(scene, camera); const dataUrl = gl.domElement.toDataURL('image/jpeg', 1.0); onCaptureReady(dataUrl); scene.background = oldBg; if (controls) controls.enabled = true; }, 300); } else if (viewMode === 'reset_view') { camera.position.set(0, 400, 200); camera.lookAt(0,0,0); if (controls) { controls.target.set(0, 0, 0); controls.update(); } setViewMode('editor'); } }, [viewMode, camera, controls, gl, scene, onCaptureReady, boardRef, boardSize, setViewMode]); return null; };
        const CameraEventsListener = ({ enabled }) => { const { camera, controls } = useThree(); useEffect(() => { if (!enabled) return; const handleCmd = (e) => { if (!controls) return; const { type, val, x, y } = e.detail; if (type === 'zoom') { camera.position.y = Math.max(50, camera.position.y + val); } else if (type === 'rotate') { const currentAzimuth = controls.getAzimuthalAngle(); controls.setAzimuthalAngle(currentAzimuth + (Math.PI/2 * val)); } else if (type === 'pan') { const speed = 50; const vecRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion).setY(0).normalize(); const vecUp = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion).setY(0).normalize(); camera.position.addScaledVector(vecRight, x * speed).addScaledVector(vecUp, y * speed); controls.target.addScaledVector(vecRight, x * speed).addScaledVector(vecUp, y * speed); } controls.update(); }; window.addEventListener('ninco-cmd', handleCmd); return () => window.removeEventListener('ninco-cmd', handleCmd); }, [enabled, camera, controls]); return null; };
        const TouchControlsOverlay = ({ enabled }) => { if (!enabled) return null; const emit = (type, payload) => { window.dispatchEvent(new CustomEvent('ninco-cmd', { detail: { type, ...payload } })); }; return ( <div className="touch-controls"> <div className="flex gap-2 mb-2"> <button className="touch-btn" onClick={() => emit('zoom', { val: -50 })}><ZoomIn size={24} /></button> <button className="touch-btn" onClick={() => emit('zoom', { val: 50 })}><ZoomOut size={24} /></button> </div> <div className="flex gap-2 mb-2"> <button className="touch-btn" onClick={() => emit('rotate', { val: -1 })}><RotateCcw size={24} /></button> <button className="touch-btn" onClick={() => emit('rotate', { val: 1 })}><RotateCw size={24} /></button> </div> <div className="flex flex-col items-center gap-1 bg-black/80 p-2 rounded-xl border border-gray-800 shadow-xl backdrop-blur-sm"> <button className="touch-pad-btn" onClick={() => emit('pan', { x: 0, y: 1 })}><ArrowUp size={24}/></button> <div className="flex gap-1"><button className="touch-pad-btn" onClick={() => emit('pan', { x: -1, y: 0 })}><ArrowLeft size={24}/></button><div className="w-[45px] h-[45px] flex items-center justify-center text-slate-500"><Move size={20}/></div><button className="touch-pad-btn" onClick={() => emit('pan', { x: 1, y: 0 })}><ArrowRight size={24}/></button></div> <button className="touch-pad-btn" onClick={() => emit('pan', { x: 0, y: -1 })}><ArrowDown size={24}/></button> </div> </div> ); };

        const PreviewModal = ({ data, onClose }) => {
            return (
                <div className="absolute inset-0 z-[200] flex items-center justify-center bg-black/80 backdrop-blur-sm animate-fade-in p-4">
                     <div className="bg-slate-900 border border-slate-700 rounded-xl shadow-2xl w-full max-w-lg h-[60vh] flex flex-col relative overflow-hidden">
                        <div className="absolute top-0 left-0 w-full p-3 flex justify-between items-center z-10 bg-gradient-to-b from-black/80 to-transparent pointer-events-none">
                            <h3 className="text-white font-bold uppercase tracking-wider drop-shadow-md px-2">{data.name}</h3>
                            <button onClick={onClose} className="p-1 rounded-full bg-black/50 hover:bg-red-600 text-white transition pointer-events-auto"><X size={20}/></button>
                        </div>
                        <Canvas shadows dpr={[1, 2]} camera={{ position: [0, 0, 10], fov: 50 }}>
                             <color attach="background" args={['#0f172a']} />
                             <ambientLight intensity={1.5} />
                             <directionalLight position={[5, 10, 5]} intensity={2} />
                             <pointLight position={[-10, -10, -10]} intensity={0.5} color="white" />
                             <Suspense fallback={null}>
                                <Stage environment={null} intensity={1} adjustCamera={1.2}>
                                    {data.type === 'CAR' ? (
                                        <CarModel 
                                            type={data.subType || 'CUSTOM_OBJ'} 
                                            color={data.color} 
                                            customData={{obj: data.obj, mtl: data.mtl, tex: data.tex}} 
                                            rotationZ={data.specs?.rotation?.z || 0} 
                                            rotationX={data.specs?.rotation?.x || 0} 
                                            offsetY={data.specs?.offset?.y || 0} 
                                            offsetZ={data.specs?.offset?.z || 0} 
                                            offsetX={data.specs?.offset?.x || 0}
                                        />
                                    ) : (
                                        <DecorationObject objUrl={data.obj} mtlUrl={data.mtl} isSelected={false} />
                                    )}
                                </Stage>
                             </Suspense>
                             <OrbitControls makeDefault autoRotate autoRotateSpeed={2} />
                        </Canvas>
                        <div className="p-3 bg-slate-800 border-t border-slate-700 text-center">
                            <p className="text-xs text-slate-400 font-mono">Vista Previa 3D - Arrastra para rotar</p>
                        </div>
                     </div>
                </div>
            );
        };

        function App() {
            const [appMode, setAppMode] = useState('builder'); 
            const [currentSystem, setCurrentSystem] = useState('ninco'); 
            const [boardSize, setBoardSize] = useState({ width: 0, length: 0 }); 
            const [inputSize, setInputSize] = useState({ width: '122', length: '244' });
            const [showBoardConfig, setShowBoardConfig] = useState(true);
            const [moveMode, setMoveMode] = useState('none'); 
            const boardRef = useRef();
            const fileInputRef = useRef();
            const objInputRef = useRef();
            const mtlInputRef = useRef();
            const imgInputRef = useRef(); 
            const decoObjRef = useRef();
            const decoMtlRef = useRef();
            const [decoMode, setDecoMode] = useState(false);
            const [customDecos, setCustomDecos] = useState([]);
            const [placedDecos, setPlacedDecos] = useState([]);
            const [activeDecoId, setActiveDecoId] = useState(null);
            const [selectedDecoInstance, setSelectedDecoInstance] = useState(null);
            const [isCrashed, setIsCrashed] = useState(false);
            const [confirmModal, setConfirmModal] = useState(null);
            const [previewData, setPreviewData] = useState(null);
            const [importState, setImportState] = useState({ name: '', obj: null, mtl: null, tex: null, objBlob: null, mtlBlob: null, texBlob: null });
            const [tempSpecs, setTempSpecs] = useState({ offset: {x:0, y:0, z:0}, rotation: {y:-90, z:0, x:0} });

            const initAudio = async () => { if (window.Tone) { await Tone.start(); Tone.Transport.start(); } };
            const playToneBeep = (note = "A4", duration = "0.1") => { if (!window.Tone) return; const synth = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(); synth.volume.value = -5; synth.triggerAttackRelease(note, duration); };
            const playToneStart = () => { if (!window.Tone) return; const poly = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.5, release: 1 } }).toDestination(); poly.volume.value = -2; poly.triggerAttackRelease(["C4", "E4", "G4", "C5"], 0.6); };
            const playCrashSound = () => { if (!window.Tone) return; const noise = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.3, sustain: 0 } }).toDestination(); noise.triggerAttackRelease("0.3"); };
            const speak = (text, interrupt = false) => { if (!window.speechSynthesis) return; if (interrupt) window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(text); u.lang = 'es-ES'; u.rate = 1.1; window.speechSynthesis.speak(u); };

            const [carEnabled, setCarEnabled] = useState(true); 
            const [carThrottle, setCarThrottle] = useState(0); 
            const [selectedLane, setSelectedLane] = useState(1); 
            const [selectedVoltage, setSelectedVoltage] = useState(12);
            const [carWeight, setCarWeight] = useState(85); 
            const [selectedCarModelId, setSelectedCarModelId] = useState('gt3_red');
            const [customCars, setCustomCars] = useState([]);
            const [motors, setMotors] = useState(INITIAL_MOTORS);
            const [tires, setTires] = useState(INITIAL_TIRES);
            const [selectedMotor, setSelectedMotor] = useState(INITIAL_MOTORS[1]); 
            const [selectedTire, setSelectedTire] = useState(INITIAL_TIRES[1]);
            const [driveMode, setDriveMode] = useState('manual'); 
            const [targetLaps, setTargetLaps] = useState(10);
            const [raceState, setRaceState] = useState('idle'); 
            const [lightStep, setLightStep] = useState(0);
            const [raceData, setRaceData] = useState({ currentLap: 0, lastLapTime: 0, bestLap: 0, totalTime: 0, avgLap: 0 });
            const raceStartTime = useRef(0);
            const [resetToken, setResetToken] = useState(0); 
            const [telemetry, setTelemetry] = useState({ speed: 0, limit: 100, section: 'STD', throttle: 0, gForce: 0, gripLimit: 0 });
            const [segments, setSegments] = useState([ { id: 1, pId: 'STD', dir: 1, type: 'START', pos: new THREE.Vector3(), rot: new THREE.Euler() } ]);
            const [selId, setSelId] = useState(1);
            const [nextDir, setNextDir] = useState(1);
            const [viewMode, setViewMode] = useState('editor'); 
            const [snapshotUrl, setSnapshotUrl] = useState(null);

            useEffect(() => {
                const loadPersistentData = async () => {
                    try {
                        const savedCars = await get('ninco-custom-cars');
                        if (savedCars && Array.isArray(savedCars)) {
                            const hydratedCars = savedCars.map(c => ({ ...c, customData: { obj: c.storage?.objBlob ? URL.createObjectURL(c.storage.objBlob) : null, mtl: c.storage?.mtlBlob ? URL.createObjectURL(c.storage.mtlBlob) : null, tex: c.storage?.texBlob ? URL.createObjectURL(c.storage.texBlob) : null } }));
                            setCustomCars(hydratedCars);
                        }
                        const savedDecos = await get('ninco-custom-decos');
                        if (savedDecos && Array.isArray(savedDecos)) {
                            const hydratedDecos = savedDecos.map(d => ({ ...d, customData: { obj: d.storage?.objBlob ? URL.createObjectURL(d.storage.objBlob) : null, mtl: d.storage?.mtlBlob ? URL.createObjectURL(d.storage.mtlBlob) : null } }));
                            setCustomDecos(hydratedDecos);
                        }
                        const savedMotors = await get('ninco-motors'); if (savedMotors) setMotors(savedMotors);
                        const savedTires = await get('ninco-tires'); if (savedTires) setTires(savedTires);
                    } catch (err) { console.error("Error cargando datos persistentes:", err); }
                };
                loadPersistentData();
            }, []);
            
            const systemSpecs = TRACK_SYSTEMS[currentSystem];
            const piecesDef = useMemo(() => getPieces(systemSpecs), [currentSystem]);
            const { tracks, pieceMaps, pointerMatrix } = useMemo(() => {
                const allTracks = [];
                let currentTrack = [];
                const maps = {};
                let matrix = new THREE.Matrix4();
                
                segments.forEach(seg => {
                    if (seg.type === 'START') {
                        if (currentTrack.length > 0) {
                            allTracks.push(currentTrack);
                            currentTrack = [];
                        }
                        matrix = new THREE.Matrix4().makeRotationFromEuler(seg.rot);
                        matrix.setPosition(seg.pos);
                    }
                    const def = piecesDef[seg.pId];
                    if (!def) return;

                    const isLeft = seg.dir === 1; const currentPos = new THREE.Vector3(); const currentRot = new THREE.Quaternion(); const currentScale = new THREE.Vector3(); matrix.decompose(currentPos, currentRot, currentScale);
                    const segmentData = { ...seg, pos: currentPos, rot: new THREE.Euler().setFromQuaternion(currentRot), mat: matrix.clone() }; 
                    
                    currentTrack.push(segmentData);
                    maps[seg.id] = segmentData;

                    const transform = new THREE.Matrix4(); if (def.type === 'STRAIGHT') { transform.makeTranslation(def.len, 0, 0); } else { const rad = (def.ang * Math.PI) / 180; const dx = def.r * Math.sin(rad); const dz = def.r * (1 - Math.cos(rad)) * (isLeft ? -1 : 1); const translation = new THREE.Matrix4().makeTranslation(dx, 0, dz); const rotation = new THREE.Matrix4().makeRotationY(isLeft ? rad : -rad); transform.multiply(translation).multiply(rotation); } matrix.multiply(transform);
                });
                if (currentTrack.length > 0) allTracks.push(currentTrack);
                return { tracks: allTracks, pieceMaps: maps, pointerMatrix: matrix };
            }, [segments, piecesDef]);

            const chain = useMemo(() => tracks.flat(), [tracks]);
            
            const stats = useMemo(() => {
                let totalLen = 0; const counts = {}; chain.forEach(seg => { const def = piecesDef[seg.pId]; if(!def) return; counts[def.label] = (counts[def.label] || 0) + 1; if (def.type === 'STRAIGHT') { totalLen += (def.len * 2); } else { const rad = (def.ang * Math.PI) / 180; totalLen += (rad * (def.r - systemSpecs.railOffset)) + (rad * (def.r + systemSpecs.railOffset)); } });
                const inventoryList = Object.entries(counts); return { totalLen: (totalLen / 100).toFixed(2), inventory: inventoryList, totalPieces: inventoryList.reduce((acc, [_, c]) => acc + c, 0) };
            }, [chain, piecesDef, systemSpecs]);
            
            const generateReport = () => { setViewMode('capturing'); };
            const handleCaptureReady = (url) => { setSnapshotUrl(url); setViewMode('report'); };
            const downloadPDF = () => { const element = document.getElementById('printable-area'); if (!element) return; const container = document.createElement('div'); container.style.position = 'absolute'; container.style.top = '-9999px'; container.style.left = '0'; container.style.width = '1123px'; container.style.zIndex = '-1'; const clone = element.cloneNode(true); clone.style.width = '100%'; clone.style.height = 'auto'; clone.style.color = '#000'; clone.style.background = '#fff'; container.appendChild(clone); document.body.appendChild(container); const opt = { margin: 10, filename: `ninco-track-${Date.now()}.pdf`, image: { type: 'jpeg', quality: 0.98 }, html2canvas: { scale: 2, useCORS: true, scrollY: 0, windowWidth: 1200 }, jsPDF: { unit: 'mm', format: 'a4', orientation: 'landscape' } }; if (window.html2pdf) { window.html2pdf().set(opt).from(clone).save().then(() => { document.body.removeChild(container); }).catch(err => { console.error("PDF Error", err); document.body.removeChild(container); }); } else { document.body.removeChild(container); setConfirmModal({ message: "Librería PDF no cargada.", onConfirm: () => { window.print(); setConfirmModal(null); }, isAlert: true }); } };
            const startBuilder = () => { setBoardSize({ width: parseFloat(inputSize.width), length: parseFloat(inputSize.length) }); setSegments([{ id: 1, pId: 'STD', dir: 1, type: 'START', pos: new THREE.Vector3(), rot: new THREE.Euler() }]); setSelId(1); setShowBoardConfig(false); if (window.Tone) { initAudio().catch(e => console.log("Audio init failed", e)); } };
            const add = (pId) => { if(viewMode!=='editor') return; const newId = Date.now() + Math.random(); setSegments(prev => [...prev, { id: newId, pId, dir: nextDir, type: 'PIECE' }]); setSelId(newId); };
            const del = () => { if(viewMode!=='editor') return; const f = segments.filter(s => s.id !== selId); setSegments(f); if(f.length > 0) setSelId(f[f.length-1].id); };
            const undo = () => { if(viewMode!=='editor') return; if(segments.length > 1) { const newSegs = segments.slice(0, -1); setSegments(newSegs); setSelId(newSegs[newSegs.length-1].id); } };
            const flip = () => { if(viewMode!=='editor') return; const s = segments.find(x => x.id === selId); if(s && piecesDef[s.pId].type === 'CURVE') { setSegments(segments.map(x => x.id === selId ? {...x, dir: x.dir * -1} : x)); } };
            const toggleFence = () => { if(viewMode!=='editor') return; setSegments(prev => prev.map(s => s.id === selId ? { ...s, showFence: s.showFence === false ? true : false } : s)); speak("Vallas alternadas"); };
            const reset = () => { setConfirmModal({ message: "¿Reiniciar todo?", onConfirm: () => { setSegments([{ id: 1, pId: 'STD', dir: 1, type: 'START', pos: new THREE.Vector3(), rot: new THREE.Euler() }]); setPlacedDecos([]); setSelId(1); setConfirmModal(null); } }); };
            const handlePieceClick = (e, id) => { if(viewMode!=='editor' || appMode !== 'builder' || moveMode === 'track' || decoMode) return; e.stopPropagation(); setSelId(id); };
            const rotateBoardOnly = () => { if (boardRef.current) { boardRef.current.rotation.z += Math.PI / 2; speak("Tablero girado"); } };
            const rotateTrackOnly = () => { setSegments(prev => prev.map(seg => { if (seg.type === 'START') { const vec = new THREE.Vector3(seg.pos.x, seg.pos.y, seg.pos.z); vec.applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2); const originalRot = new THREE.Euler(seg.rot.x, seg.rot.y, seg.rot.z); const q = new THREE.Quaternion().setFromEuler(originalRot); const rotQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2); q.premultiply(rotQ); const newRot = new THREE.Euler().setFromQuaternion(q); return { ...seg, pos: vec, rot: newRot }; } return seg; })); setPlacedDecos(prev => prev.map(deco => { const vec = new THREE.Vector3(deco.position[0], deco.position[1], deco.position[2]); vec.applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2); const newRotY = deco.rotation[1] + Math.PI / 2; return { ...deco, position: [vec.x, vec.y, vec.z], rotation: [deco.rotation[0], newRotY, deco.rotation[2]] }; })); speak("Pista girada"); };
            const spawnParallel = (direction) => { const selectedData = pieceMaps[selId]; if (!selectedData) return; const offset = direction === 'left' ? -systemSpecs.width : systemSpecs.width; const m = selectedData.mat.clone(); m.multiply(new THREE.Matrix4().makeTranslation(0, 0, offset)); const pos = new THREE.Vector3(); const rotQ = new THREE.Quaternion(); const scale = new THREE.Vector3(); m.decompose(pos, rotQ, scale); const rot = new THREE.Euler().setFromQuaternion(rotQ); const newId = Date.now(); setSegments(prev => [...prev, { id: newId, pId: 'STD', dir: 1, type: 'START', pos: pos, rot: rot }]); setSelId(newId); };
            const createLanes = (totalLanes) => { 
                const selectedData = pieceMaps[selId]; 
                if (!selectedData) { speak("Selecciona una recta"); return; } 
                if (piecesDef[selectedData.pId]?.type !== 'STRAIGHT') { speak("Solo en rectas"); return; } 
                const tracksNeeded = (totalLanes / 2) - 1; 
                if (tracksNeeded <= 0) return; 
                
                let newSegments = []; 
                const currentDir = selectedData.dir !== undefined ? selectedData.dir : 1; 
                
                // Identify the 'current' track that we are extending from to remove its fences
                const selectedTrackIndex = tracks.findIndex(t => t.some(s => s.id === selId));
                let segmentsToDisableFences = [];
                if (selectedTrackIndex !== -1) {
                    segmentsToDisableFences = tracks[selectedTrackIndex].map(s => s.id);
                }

                for (let i = 1; i <= tracksNeeded; i++) { 
                    const offset = systemSpecs.width * i; 
                    const m = selectedData.mat.clone(); 
                    m.multiply(new THREE.Matrix4().makeTranslation(0, 0, offset)); 
                    const pos = new THREE.Vector3(); 
                    const rotQ = new THREE.Quaternion(); 
                    const scale = new THREE.Vector3(); 
                    m.decompose(pos, rotQ, scale); 
                    const rot = new THREE.Euler().setFromQuaternion(rotQ); 
                    // New tracks keep fences (outermost), older ones lose them
                    newSegments.push({ id: Date.now() + i + Math.random(), pId: 'STD', dir: currentDir, type: 'START', pos: pos, rot: rot, showFence: true }); 
                } 
                
                setSegments(prev => { 
                    // Update previous segments to remove fences if they belong to the inner track
                    const updatedPrev = prev.map(s => segmentsToDisableFences.includes(s.id) ? { ...s, showFence: false } : s);
                    const updated = [...updatedPrev, ...newSegments]; 
                    if (newSegments.length > 0) { setTimeout(() => setSelId(newSegments[newSegments.length-1].id), 50); } 
                    return updated; 
                }); 
                speak(`${totalLanes} carriles`); 
            };
            const toggleSystem = () => { setConfirmModal({ message: "Cambiar de sistema reiniciará la pista actual. ¿Continuar?", onConfirm: () => { setCurrentSystem(s => s === 'ninco' ? 'scaleauto' : 'ninco'); setSegments([{ id: 1, pId: 'STD', dir: 1, type: 'START', pos: new THREE.Vector3(), rot: new THREE.Euler() }]); setConfirmModal(null); } }); };
            const updateStartPos = useCallback((id, newPos) => { setSegments(prev => { const newSegs = [...prev]; const index = newSegs.findIndex(s => s.id === id); if (index !== -1) { newSegs[index] = { ...newSegs[index], pos: newPos }; } return newSegs; }); }, []);
            const rotateStart = (deg) => { setSegments(prev => { const index = prev.findIndex(s => s.id === selId); if (index === -1) return prev; const newSegs = [...prev]; const currentRot = newSegs[index].rot; newSegs[index] = { ...newSegs[index], rot: new THREE.Euler(currentRot.x, currentRot.y + (deg * Math.PI / 180), currentRot.z) }; return newSegs; }); };
            const handleDecoObjUpload = (e) => { const file = e.target.files[0]; if (!file) return; const url = URL.createObjectURL(file); const name = file.name.split('.')[0].substring(0, 10); const newDeco = { id: `deco-${Date.now()}`, name: name, type: 'CUSTOM_DECO', customData: { obj: url, mtl: null }, storage: { objBlob: file, mtlBlob: null } }; setCustomDecos(prev => { const updated = [...prev, newDeco]; set('ninco-custom-decos', updated).catch(err => console.error("Err saving deco", err)); return updated; }); setActiveDecoId(newDeco.id); speak("Decoración importada"); e.target.value = ''; };
            const handleDecoMtlUpload = (e) => { const file = e.target.files[0]; if (!file) return; const url = URL.createObjectURL(file); if (activeDecoId) { setCustomDecos(prev => { const updated = prev.map(d => { if (d.id === activeDecoId) { return { ...d, customData: { ...d.customData, mtl: url }, storage: { ...d.storage, mtlBlob: file } }; } return d; }); set('ninco-custom-decos', updated); return updated; }); speak("Textura aplicada"); } e.target.value = ''; };
            const placeDecoration = (point) => { if (!activeDecoId) return; const newInstance = { instanceId: Date.now(), modelId: activeDecoId, position: [point.x, 0, point.z], rotation: [0, 0, 0], scale: 1.0 }; setPlacedDecos(prev => [...prev, newInstance]); setSelectedDecoInstance(newInstance.instanceId); speak("Objeto colocado"); };
            const updateDecoInstance = (id, prop, value) => { setPlacedDecos(prev => prev.map(d => { if (d.instanceId === id) { return { ...d, [prop]: value }; } return d; })); };
            const deleteDecoInstance = (e) => { if (e && e.stopPropagation) { e.stopPropagation(); e.nativeEvent?.stopImmediatePropagation(); } if(selectedDecoInstance) { setPlacedDecos(prev => prev.filter(d => d.instanceId !== selectedDecoInstance)); setSelectedDecoInstance(null); speak("Objeto borrado"); } };

            const [editablePresetCars, setEditablePresetCars] = useState(PRESET_CARS);
            const allCars = useMemo(() => [...editablePresetCars, ...customCars], [editablePresetCars, customCars]);
            const activeCarData = useMemo(() => { if (importState.obj) { return { id: 'preview_import', name: importState.name || 'PREVIEW', type: 'CUSTOM_OBJ', customData: { obj: importState.obj, mtl: importState.mtl, tex: importState.tex }, specs: tempSpecs }; } return allCars.find(c => c.id === selectedCarModelId) || editablePresetCars[0]; }, [allCars, selectedCarModelId, importState, tempSpecs, editablePresetCars]);
            
            const updateCarSpec = (category, updateValues) => { if (importState.obj) { setTempSpecs(prev => { const oldCategory = prev[category] || {}; return { ...prev, [category]: { ...oldCategory, ...updateValues } }; }); return; } if (selectedCarModelId.startsWith('custom-')) { setCustomCars(prev => { const updated = prev.map(c => { if (c.id === selectedCarModelId) { const oldSpecs = c.specs || {}; const oldCategory = oldSpecs[category] || {}; const newCategory = { ...oldCategory, ...updateValues }; return { ...c, specs: { ...oldSpecs, [category]: newCategory } }; } return c; }); set('ninco-custom-cars', updated); return updated; }); } else { setEditablePresetCars(prev => prev.map(c => { if (c.id === selectedCarModelId) { const oldSpecs = c.specs || {}; const oldCategory = oldSpecs[category] || {}; const newCategory = { ...oldCategory, ...updateValues }; return { ...c, specs: { ...oldSpecs, [category]: newCategory } }; } return c; })); } };
            const handleImportFile = (type, e) => { const file = e.target.files[0]; if (!file) return; const url = URL.createObjectURL(file); setImportState(prev => ({ ...prev, [type]: url, [`${type}Blob`]: file })); if (type === 'obj') setTempSpecs({ offset: {x:0, y:0, z:0}, rotation: {y:-90, z:0, x:0} }); speak(`${type.toUpperCase()} Cargado`); };
            const saveImportedCar = () => { if (!importState.obj || !importState.name) { speak("Falta nombre o modelo"); return; } const newCar = { id: `custom-${Date.now()}`, name: importState.name, type: 'CUSTOM_OBJ', description: 'Personalizado', customData: { obj: importState.obj, mtl: importState.mtl, tex: importState.tex }, storage: { objBlob: importState.objBlob, mtlBlob: importState.mtlBlob, texBlob: importState.texBlob }, specs: JSON.parse(JSON.stringify(tempSpecs)) }; setCustomCars(prev => { const updated = [...prev, newCar]; set('ninco-custom-cars', updated); return updated; }); setImportState({ name: '', obj: null, mtl: null, tex: null, objBlob: null, mtlBlob: null, texBlob: null }); setSelectedCarModelId(newCar.id); speak("Bólido guardado"); };
            const renameCar = (id, newName) => { setCustomCars(prev => { const updated = prev.map(c => c.id === id ? { ...c, name: newName } : c); set('ninco-custom-cars', updated); return updated; }); speak("Nombre cambiado"); };
            const startRaceSequence = () => { initAudio(); setRaceState('countdown'); setLightStep(0); setRaceData({ currentLap: 0, lastLapTime: 0, bestLap: 0, totalTime: 0, avgLap: 0 }); speak("Semáforo en marcha"); };
            const pauseRace = () => { setRaceState('paused'); speak("Pausa"); };
            const resumeRace = () => { setRaceState('racing'); speak("Continuamos"); };
            const restartRace = () => { setRaceState('idle'); setCarThrottle(0); setResetToken(prev => prev + 1); setRaceData({ currentLap: 0, lastLapTime: 0, bestLap: 0, totalTime: 0, avgLap: 0 }); speak("Vuelta a Inicio"); };
            const handleDerail = () => { if (driveMode === 'ai') return; setIsCrashed(true); playCrashSound(); speak("Salida de pista", true); setCarThrottle(0); setTimeout(() => setIsCrashed(false), 2000); };
            const toggleDriveMode = () => { const newMode = driveMode === 'manual' ? 'ai' : 'manual'; setDriveMode(newMode); speak(newMode === 'ai' ? "Modo IA activado" : "Control Manual", true); setCarThrottle(0); };
            const cycleLaps = () => { const idx = LAP_OPTIONS.indexOf(targetLaps); setTargetLaps(LAP_OPTIONS[(idx + 1) % LAP_OPTIONS.length]); };
            const addMotor = () => { const newMotor = { id: `custom-${Date.now()}`, name: 'Nuevo Motor', rpm: 22000, torque: 1.1, color: '#ffffff' }; const updated = [...motors, newMotor]; setMotors(updated); setSelectedMotor(newMotor); set('ninco-motors', updated); speak("Motor añadido"); };
            const addTire = () => { const newTire = { id: `custom-${Date.now()}`, name: 'Custom', grip: 1.1, color: '#ffffff', label: 'CUST' }; const updated = [...tires, newTire]; setTires(updated); setSelectedTire(newTire); set('ninco-tires', updated); speak("Neumático añadido"); };
            const deleteCustomItem = (type, id) => { if (type === 'car') { setCustomCars(prev => { const updated = prev.filter(c => c.id !== id); set('ninco-custom-cars', updated); return updated; }); if (selectedCarModelId === id) setSelectedCarModelId('gt3_red'); } else if (type === 'motor') { setMotors(prev => { const updated = prev.filter(m => m.id !== id); set('ninco-motors', updated); return updated; }); if (selectedMotor.id === id) setSelectedMotor(INITIAL_MOTORS[0]); } else if (type === 'tire') { setTires(prev => { const updated = prev.filter(t => t.id !== id); set('ninco-tires', updated); return updated; }); if (selectedTire.id === id) setSelectedTire(INITIAL_TIRES[0]); } speak("Elemento borrado"); };
            const clearSavedData = async () => { setConfirmModal({ message: "¿Borrar todo?", onConfirm: async () => { await set('ninco-custom-cars', []); await set('ninco-custom-decos', []); await set('ninco-motors', INITIAL_MOTORS); await set('ninco-tires', INITIAL_TIRES); setCustomCars([]); setCustomDecos([]); setMotors(INITIAL_MOTORS); setTires(INITIAL_TIRES); setSelectedCarModelId('gt3_red'); setConfirmModal(null); speak("Datos borrados"); } }); };
            const saveCircuit = () => { const data = { version: 1, system: currentSystem, board: boardSize, segments: segments, decorations: placedDecos }; const blob = new Blob([JSON.stringify(data)], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `circuito-${currentSystem}-${Date.now()}.json`; a.click(); URL.revokeObjectURL(url); speak("Circuito guardado"); };
            const loadCircuit = (e) => { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (event) => { try { const data = JSON.parse(event.target.result); if (data.segments && data.system) { setCurrentSystem(data.system); setBoardSize(data.board || { width: 244, length: 122 }); const restoredSegments = data.segments.map(s => { const newPos = s.pos ? new THREE.Vector3(s.pos.x, s.pos.y, s.pos.z) : undefined; const newRot = s.rot ? new THREE.Euler(s.rot._x !== undefined ? s.rot._x : s.rot.x, s.rot._y !== undefined ? s.rot._y : s.rot.y, s.rot._z !== undefined ? s.rot._z : s.rot.z, s.rot._order || s.rot.order || 'XYZ') : undefined; const cleanSegment = { ...s }; if (newPos) cleanSegment.pos = newPos; if (newRot) cleanSegment.rot = newRot; return cleanSegment; }); setSegments(restoredSegments); setSelId(restoredSegments[0].id); if (data.decorations && Array.isArray(data.decorations)) { setPlacedDecos(data.decorations); } speak("Circuito cargado"); } else { setConfirmModal({ message: "Formato de archivo no válido", onConfirm: () => setConfirmModal(null), isAlert: true }); } } catch (err) { console.error(err); setConfirmModal({ message: "Error al leer el archivo.", onConfirm: () => setConfirmModal(null), isAlert: true }); } e.target.value = ''; }; reader.readAsText(file); };

            useEffect(() => { let timeoutId; if (raceState === 'countdown' && lightStep >= 1 && lightStep <= 5) { playToneBeep("G4", "0.15"); } else if (raceState === 'racing' && lightStep === 6) { playToneStart(); raceStartTime.current = Date.now(); } return () => clearTimeout(timeoutId); }, [lightStep, raceState]);
            useEffect(() => { let interval; if (raceState === 'countdown') { interval = setInterval(() => { setLightStep(prev => { if (prev >= 5) { setRaceState('racing'); clearInterval(interval); return 6; } return prev + 1; }); }, 1000); } return () => clearInterval(interval); }, [raceState]);
            useEffect(() => { let int; if(raceState === 'racing') { int = setInterval(() => { setRaceData(prev => ({...prev, totalTime: (Date.now() - raceStartTime.current)/1000})); }, 100); } return () => clearInterval(int); }, [raceState]);
            const handleLap = (lapTime) => { if (raceState === 'finished') return; setRaceData(prev => { const newLap = prev.currentLap + 1; const isBestLap = (prev.bestLap === 0 || lapTime < prev.bestLap); const totalRecordedTime = (prev.avgLap * prev.currentLap) + lapTime; const newAvg = totalRecordedTime / newLap; if (raceState === 'racing' && newLap >= targetLaps && targetLaps !== Infinity) { setRaceState('finished'); speak("Carrera finalizada", true); setCarThrottle(0); } else if (isBestLap && lapTime > 0) { speak(`Rápida, ${lapTime.toFixed(2)}`); } return { ...prev, currentLap: newLap, lastLapTime: lapTime, bestLap: isBestLap ? lapTime : prev.bestLap, avgLap: newAvg }; }); };
            const handleTelemetry = (data) => { setTelemetry(data); };
            const formatTime = (t) => { const m = Math.floor(t / 60); const s = Math.floor(t % 60); const ms = Math.floor((t * 10) % 10); return `${m}:${s.toString().padStart(2, '0')}.${ms}`; };
            const isSelectionStart = useMemo(() => { const s = segments.find(seg => seg.id === selId); return s && s.type === 'START'; }, [selId, segments]);
            const activeDecoData = useMemo(() => customDecos.find(d => d.id === activeDecoId) || BASE_DECOS[0], [customDecos, activeDecoId]);
            const selectedDecoObject = useMemo(() => placedDecos.find(d => d.instanceId === selectedDecoInstance), [placedDecos, selectedDecoInstance]);

            return (
                <div className="app-container">
                    {/* SIDEBAR - SINGLE CONTAINER */}
                    <div className="sidebar no-print">
                        <div className="sidebar-header">
                            <h1 className="main-title-neon mb-1">{appMode === 'racer' ? 'RACE CONTROL' : 'TRACKS & TELEMETRY V.1.01'}</h1>
                            <div className="text-[9px] font-bold text-slate-500 uppercase tracking-widest mt-2 border-t border-slate-900 pt-2">{systemSpecs.name} SYSTEM</div>
                        </div>

                        <div className="sidebar-content">
                            <div className="sidebar-section">
                                <div className="flex gap-2">
                                    <div onClick={() => setAppMode('builder')} className={`tab-btn flex-1 ${appMode === 'builder' ? 'active' : ''}`}><PenTool size={14} /> DISEÑO</div>
                                    <div onClick={() => setAppMode('racer')} className={`tab-btn flex-1 ${appMode === 'racer' ? 'active' : ''}`}><CarFront size={14} /> PILOTO</div>
                                </div>
                            </div>

                            {/* BUILDER MODE TOOLS */}
                            {appMode === 'builder' && viewMode === 'editor' && !decoMode && (
                                <>
                                    <div className="sidebar-section">
                                        <div className="sidebar-section-title">Espacio de Trabajo</div>
                                        <div className="mb-3 bg-slate-900/30 p-2 rounded border border-slate-800">
                                            <span className="text-[9px] font-bold text-slate-500 uppercase block mb-1 tracking-wider">TABLERO DE MADERA</span>
                                            <div className="btn-grid-2">
                                                <button onClick={() => setMoveMode(m => m === 'board' ? 'none' : 'board')} className={`btn-tile flex-row gap-2 h-10 ${moveMode === 'board' ? 'active-tool' : ''}`} title="Mover Tablero"><LayoutTemplate size={16} /><span className="btn-label mt-0">MOVER</span></button>
                                                <button onClick={rotateBoardOnly} className="btn-tile flex-row gap-2 h-10" title="Girar solo el tablero"><RotateCw size={16} /><span className="btn-label mt-0">GIRAR</span></button>
                                            </div>
                                        </div>
                                        <div className="bg-slate-900/30 p-2 rounded border border-slate-800">
                                            <span className="text-[9px] font-bold text-slate-500 uppercase block mb-1 tracking-wider">CIRCUITO COMPLETO</span>
                                            <div className="btn-grid-2">
                                                <button onClick={() => setMoveMode(m => m === 'track' ? 'none' : 'track')} className={`btn-tile flex-row gap-2 h-10 ${moveMode === 'track' ? 'active-tool' : ''}`} title="Mover Pista"><Move3d size={16} /><span className="btn-label mt-0">MOVER</span></button>
                                                <button onClick={rotateTrackOnly} className="btn-tile flex-row gap-2 h-10" title="Girar solo la pista"><RotateCw size={16} /><span className="btn-label mt-0">GIRAR</span></button>
                                            </div>
                                        </div>
                                        <div className="btn-grid-2 mt-2">
                                            <button onClick={() => { setDecoMode(true); setMoveMode('none'); speak("Modo Decoración"); }} className="btn-tile flex-row gap-2 h-10" title="Decoración"><TreePine size={16} /><span className="btn-label mt-0">DECO</span></button>
                                            <button onClick={toggleSystem} className="btn-tile h-10 border-dashed"><span className="btn-label text-slate-400">ESCALA 1:32 / 1:24</span></button>
                                        </div>
                                    </div>
                                    <div className="sidebar-section">
                                        <div className="sidebar-section-title text-cyan-500">Multicarril</div>
                                        <div className="flex gap-1">
                                            <button onClick={()=>createLanes(4)} className="btn-tile flex-1 h-10 border-blue-900/50 bg-blue-950/20 text-blue-400 hover:border-blue-400 hover:text-white" title="Crear 4 Carriles"><span className="text-lg font-black leading-none">4</span><span className="text-[7px] font-bold">CARRILES</span></button>
                                            <button onClick={()=>createLanes(6)} className="btn-tile flex-1 h-10 border-purple-900/50 bg-purple-950/20 text-purple-400 hover:border-purple-400 hover:text-white" title="Crear 6 Carriles"><span className="text-lg font-black leading-none">6</span><span className="text-[7px] font-bold">CARRILES</span></button>
                                            <button onClick={()=>createLanes(8)} className="btn-tile flex-1 h-10 border-pink-900/50 bg-pink-950/20 text-pink-400 hover:border-pink-400 hover:text-white" title="Crear 8 Carriles"><span className="text-lg font-black leading-none">8</span><span className="text-[7px] font-bold">CARRILES</span></button>
                                        </div>
                                    </div>
                                    <div className="sidebar-section">
                                        <div className="sidebar-section-title">Rectas</div>
                                        <div className="btn-grid-4">
                                            <button onClick={()=>add('STD')} className="btn-tile"><div className="icon-straight w-6 h-3"></div><span className="btn-label">STD</span></button>
                                            <button onClick={()=>add('CONEX')} className="btn-tile"><div className="icon-power"></div><span className="btn-label text-red-400">POW</span></button>
                                            <button onClick={()=>add('HALF')} className="btn-tile"><div className="icon-straight w-3 h-3"></div><span className="btn-label">1/2</span></button>
                                            <button onClick={()=>add('QTR')} className="btn-tile"><div className="icon-straight w-2 h-3"></div><span className="btn-label">1/4</span></button>
                                        </div>
                                        <div className="btn-grid-2 mt-1">
                                             <button onClick={()=>add('XO')} className="btn-tile h-10 flex-row gap-2"><div className="icon-cross scale-75"></div><span className="btn-label mt-0">CRUCE</span></button>
                                        </div>
                                    </div>
                                    <div className="sidebar-section">
                                        <div className="sidebar-section-title">Curvas</div>
                                        <div className="btn-grid-3">
                                            <button onClick={()=>add('R1')} className="btn-tile"><div className="icon-curve r1-css"></div><span className="btn-label text-red-500">R1</span></button>
                                            <button onClick={()=>add('R2')} className="btn-tile"><div className="icon-curve r2-css"></div><span className="btn-label text-green-500">R2</span></button>
                                            <button onClick={()=>add('R3')} className="btn-tile"><div className="icon-curve r3-css"></div><span className="btn-label text-yellow-500">R3</span></button>
                                            <button onClick={()=>add('R4')} className="btn-tile"><div className="icon-curve r4-css"></div><span className="btn-label text-blue-500">R4</span></button>
                                            <button onClick={()=>add('R5')} className="btn-tile"><div className="icon-curve r5-css"></div><span className="btn-label text-indigo-500">R5</span></button>
                                        </div>
                                        <div className="btn-grid-2 mt-2">
                                            <button onClick={()=>add('R1H')} className="btn-tile flex-row gap-1 h-8"><div className="icon-curve r1-css scale-50"></div><span className="btn-label mt-0 text-red-400">½ R1</span></button>
                                            <button onClick={()=>add('R2H')} className="btn-tile flex-row gap-1 h-8"><div className="icon-curve r2-css scale-50"></div><span className="btn-label mt-0 text-green-400">½ R2</span></button>
                                        </div>
                                    </div>
                                    <div className="sidebar-section">
                                        <div className="sidebar-section-title">Edición</div>
                                        <div className="btn-grid-2">
                                            <button onClick={()=>setNextDir(d => d*-1)} className="btn-tile flex-row gap-2 h-10"><ArrowLeftRight size={18} className={nextDir===1?'text-indigo-400':'text-orange-400'}/><span className="btn-label mt-0">DIR</span></button>
                                            <button onClick={flip} className="btn-tile flex-row gap-2 h-10"><RotateCw size={18} /><span className="btn-label mt-0">GIRAR</span></button>
                                            <button onClick={undo} className="btn-tile flex-row gap-2 h-10 text-yellow-500"><Undo2 size={18} /><span className="btn-label mt-0">DESHACER</span></button>
                                            <button onClick={del} className="btn-tile btn-danger flex-row gap-2 h-10 border-red-900/50 text-red-400"><Trash2 size={18} /><span className="btn-label mt-0">BORRAR</span></button>
                                        </div>
                                        {isSelectionStart && moveMode === 'none' && (
                                            <div className="flex gap-1 mt-2 bg-blue-900/20 p-1 rounded border border-blue-500/30 justify-center">
                                                <button onClick={()=>rotateStart(-5)} className="p-1 hover:text-white text-blue-300"><RotateCcw size={14}/></button>
                                                <span className="text-[9px] font-bold text-blue-300 self-center px-1">SALIDA</span>
                                                <button onClick={()=>rotateStart(5)} className="p-1 hover:text-white text-blue-300"><RotateCw size={14}/></button>
                                                <button onClick={()=>rotateStart(90)} className="ml-1 text-[9px] font-bold text-blue-300 border-l border-blue-700 pl-2">90º</button>
                                            </div>
                                        )}
                                        <button onClick={()=>spawnParallel('left')} className="btn-new-circuit mt-1 h-8 flex-row gap-2"><CopyPlus size={14} /><span>DUPLICAR PISTA</span></button>
                                        <button onClick={toggleFence} className="btn-new-circuit mt-1 h-8 flex-row gap-2 border-purple-900/50 text-purple-300"><LayoutTemplate size={14} /><span>VALLAS ON/OFF</span></button>
                                    </div>
                                    <div className="sidebar-section border-none">
                                        <div className="sidebar-section-title">Archivo</div>
                                        <div className="btn-grid-3">
                                            <button onClick={saveCircuit} className="btn-tile h-12 bg-green-900/30 border-green-700 text-green-100"><Save size={18}/><span className="btn-label text-green-400">GUARDAR</span></button>
                                            <button onClick={()=>fileInputRef.current.click()} className="btn-tile h-12 bg-slate-700 border-slate-600"><FolderOpen size={18}/><span className="btn-label">ABRIR</span></button>
                                            <button onClick={generateReport} className="btn-tile h-12 bg-red-900/30 border-red-700 text-red-100"><FileText size={18}/><span className="btn-label text-red-400">PDF</span></button>
                                        </div>
                                        <div className="btn-grid-2 mt-2">
                                            <button onClick={()=>setViewMode('reset_view')} className="btn-tile h-10 flex-row gap-2 bg-indigo-900/20 border-indigo-700"><Home size={14}/><span className="btn-label mt-0 text-indigo-300">CENTRAR</span></button>
                                            <button onClick={reset} className="btn-tile btn-danger h-10 flex-row gap-2 bg-red-950/30 border-red-900"><RotateCcw size={14}/><span className="btn-label mt-0 text-red-500">REINICIAR</span></button>
                                        </div>
                                        <button onClick={()=>setShowBoardConfig(true)} className="w-full text-[9px] text-slate-500 uppercase mt-4 hover:text-white text-center">Configurar Dimensiones</button>
                                        <input type="file" ref={fileInputRef} onChange={loadCircuit} accept=".json" style={{display:'none'}} />
                                    </div>
                                </>
                            )}
                            
                            {/* DECORATION MODE */}
                            {decoMode && viewMode === 'editor' && (
                                <>
                                    <div className="sidebar-section">
                                        <div className="flex justify-between items-center mb-2">
                                            <div className="text-purple-400 font-bold uppercase text-xs tracking-wider flex items-center gap-2"><Trees size={16}/> DECORACIÓN</div>
                                            <button onClick={()=>{setDecoMode(false); speak("Modo Pista");}} className="text-[9px] bg-slate-700 px-2 py-1 rounded hover:bg-white hover:text-black">CERRAR</button>
                                        </div>
                                        
                                        {selectedDecoObject ? (
                                             <div className="flex flex-col gap-2 bg-slate-800 p-2 rounded border border-slate-600">
                                                 <span className="text-[9px] font-bold text-slate-400 uppercase text-center border-b border-slate-700 pb-1 mb-1">OBJETO SELECCIONADO</span>
                                                 <div className="flex justify-between items-center px-1">
                                                     <span className="text-[8px] font-bold text-slate-500">DIRECCIÓN (Y)</span>
                                                     <div className="flex gap-1">
                                                         <button onClick={(e)=>{ e.stopPropagation(); updateDecoInstance(selectedDecoObject.instanceId, 'rotation', [selectedDecoObject.rotation[0], selectedDecoObject.rotation[1] - Math.PI/4, selectedDecoObject.rotation[2]]); }} className="p-1.5 bg-slate-700 rounded hover:bg-cyan-600 transition"><RotateCcw size={14}/></button>
                                                         <button onClick={(e)=>{ e.stopPropagation(); updateDecoInstance(selectedDecoObject.instanceId, 'rotation', [selectedDecoObject.rotation[0], selectedDecoObject.rotation[1] + Math.PI/4, selectedDecoObject.rotation[2]]); }} className="p-1.5 bg-slate-700 rounded hover:bg-cyan-600 transition"><RotateCw size={14}/></button>
                                                     </div>
                                                 </div>
                                                 <div className="flex justify-between items-center px-1 border-t border-slate-700 pt-1">
                                                     <span className="text-[8px] font-bold text-yellow-500">TUMBAR (X)</span>
                                                     <div className="flex gap-1">
                                                         <button onClick={(e)=>{ e.stopPropagation(); updateDecoInstance(selectedDecoObject.instanceId, 'rotation', [selectedDecoObject.rotation[0] - Math.PI/4, selectedDecoObject.rotation[1], selectedDecoObject.rotation[2]]); }} className="p-1.5 bg-slate-700 rounded hover:bg-yellow-600 transition text-yellow-200"><RotateCcw size={14} className="rotate-90"/></button>
                                                         <button onClick={(e)=>{ e.stopPropagation(); updateDecoInstance(selectedDecoObject.instanceId, 'rotation', [selectedDecoObject.rotation[0] + Math.PI/4, selectedDecoObject.rotation[1], selectedDecoObject.rotation[2]]); }} className="p-1.5 bg-slate-700 rounded hover:bg-yellow-600 transition text-yellow-200"><RotateCw size={14} className="rotate-90"/></button>
                                                     </div>
                                                 </div>
                                                 <div className="flex justify-between items-center px-1 border-t border-slate-700 pt-1 mt-1">
                                                     <span className="text-[8px] font-bold text-blue-400">TAMAÑO</span>
                                                     <div className="flex gap-1">
                                                         <button onClick={(e)=>{ e.stopPropagation(); updateDecoInstance(selectedDecoObject.instanceId, 'scale', Math.max(0.1, selectedDecoObject.scale - 0.1)); }} className="p-1.5 bg-slate-700 rounded hover:bg-blue-600 transition"><Minus size={14}/></button>
                                                         <button onClick={(e)=>{ e.stopPropagation(); updateDecoInstance(selectedDecoObject.instanceId, 'scale', selectedDecoObject.scale + 0.1); }} className="p-1.5 bg-slate-700 rounded hover:bg-blue-600 transition"><Plus size={14}/></button>
                                                     </div>
                                                 </div>
                                                 <button onClick={deleteDecoInstance} className="w-full bg-red-900/50 hover:bg-red-600 text-white p-2 rounded mt-2 flex items-center justify-center gap-2 font-bold text-xs"><Trash2 size={14}/> ELIMINAR</button>
                                             </div>
                                        ) : (
                                            <div className="flex flex-col gap-2">
                                                <div className="text-[9px] text-slate-500 text-center">Selecciona un objeto para colocar:</div>
                                                <div className="grid grid-cols-3 gap-2">
                                                    {[...BASE_DECOS, ...customDecos].map(deco => (
                                                        <div key={deco.id} onClick={() => setActiveDecoId(deco.id)} className={`cursor-pointer flex flex-col items-center p-2 rounded border transition ${activeDecoId === deco.id ? 'bg-purple-900/50 border-purple-500 text-white' : 'bg-slate-800 border-slate-700 text-slate-400'}`}>
                                                            <BoxSelect size={16} className="mb-1"/>
                                                            <span className="text-[8px] font-bold uppercase truncate w-full text-center">{deco.name}</span>
                                                        </div>
                                                    ))}
                                                </div>
                                                <div className="mt-4 border-t border-slate-700 pt-2">
                                                    <input type="file" ref={decoObjRef} onChange={handleDecoObjUpload} accept=".obj" className="hidden" />
                                                    <button onClick={()=>decoObjRef.current.click()} className="w-full flex items-center justify-center gap-1 px-2 py-2 bg-slate-800 hover:bg-purple-700 rounded text-[9px] font-bold text-white mb-1"><Plus size={10}/> IMPORTAR .OBJ</button>
                                                    <input type="file" ref={decoMtlRef} onChange={handleDecoMtlUpload} accept=".mtl" className="hidden" />
                                                    <button onClick={()=>decoMtlRef.current.click()} className="w-full flex items-center justify-center gap-1 px-2 py-2 bg-slate-800 hover:bg-purple-700 rounded text-[9px] font-bold text-white"><Upload size={10}/> TEXTURA .MTL</button>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                </>
                            )}
                            
                            {/* RACER MODE TOOLS */}
                            {appMode === 'racer' && (
                                <>
                                    <div className="sidebar-section">
                                        <div className="sidebar-section-title">Dirección de Carrera</div>
                                        {raceState === 'countdown' ? (
                                            <button disabled className="btn-tile border-yellow-500 text-yellow-500 animate-pulse w-full"><span className="text-xs font-black">READY...</span></button>
                                        ) : (
                                            <div className="btn-grid-2">
                                                {(raceState === 'idle' || raceState === 'finished') && (
                                                    <button onClick={startRaceSequence} className="btn-tile flex-row gap-2 border-green-500 text-green-500 hover:shadow-[0_0_20px_green] col-span-2"><Play size={20} /> <span className="btn-label mt-0 text-sm">START RACE</span></button>
                                                )}
                                                {raceState === 'racing' && (
                                                    <button onClick={pauseRace} className="btn-tile flex-row gap-2 border-yellow-500 text-yellow-500 hover:shadow-[0_0_20px_yellow] col-span-2"><Pause size={20} /> <span className="btn-label mt-0 text-sm">PAUSA</span></button>
                                                )}
                                                {raceState === 'paused' && (
                                                    <>
                                                        <button onClick={resumeRace} className="btn-tile border-green-500 text-green-500"><Play size={20}/></button>
                                                        <button onClick={restartRace} className="btn-tile border-red-500 text-red-500"><RotateCcw size={20}/></button>
                                                    </>
                                                )}
                                            </div>
                                        )}
                                    </div>

                                    <div className="sidebar-section">
                                        <div className="sidebar-section-title">Piloto</div>
                                        <div className="btn-grid-4">
                                            <button onClick={() => { setSelectedLane(1); speak("Carril 1"); }} className={`btn-tile ${selectedLane === 1 ? 'active-tool' : ''}`}><span className="text-xl font-black">L1</span></button>
                                            <button onClick={() => { setSelectedLane(2); speak("Carril 2"); }} className={`btn-tile ${selectedLane === 2 ? 'active-tool' : ''}`}><span className="text-xl font-black">L2</span></button>
                                            <button onClick={() => { setSelectedLane(3); speak("Carril 3"); }} className={`btn-tile ${selectedLane === 3 ? 'active-tool' : ''}`}><span className="text-xl font-black">L3</span></button>
                                            <button onClick={() => { setSelectedLane(4); speak("Carril 4"); }} className={`btn-tile ${selectedLane === 4 ? 'active-tool' : ''}`}><span className="text-xl font-black">L4</span></button>
                                        </div>
                                        <button onClick={toggleDriveMode} className={`btn-tile w-full mt-2 flex-row gap-2 ${driveMode === 'ai' ? 'border-blue-500 text-blue-400' : ''}`}><Bot size={18} /><span className="btn-label mt-0">{driveMode === 'ai' ? 'PILOTO AUTOMÁTICO (IA)' : 'CONTROL MANUAL'}</span></button>
                                        
                                        <div className="flex items-center justify-between mt-2 bg-slate-900/40 p-2 rounded border border-slate-800">
                                            <div className="flex items-center gap-2">
                                                <Zap size={14} className={selectedVoltage === 14 ? "text-yellow-400" : "text-blue-400"} />
                                                <span className="text-[9px] font-bold text-slate-400 uppercase">Voltaje Pista</span>
                                            </div>
                                            <div className="flex gap-1">
                                                <button onClick={() => { setSelectedVoltage(12); speak("12 Voltios"); }} className={`px-3 py-1.5 rounded text-[9px] font-bold border transition ${selectedVoltage === 12 ? 'bg-blue-900/50 border-blue-500 text-blue-100 shadow-[0_0_10px_rgba(59,130,246,0.3)]' : 'bg-slate-800 border-slate-700 text-slate-500 hover:bg-slate-700'}`}>12V</button>
                                                <button onClick={() => { setSelectedVoltage(14); speak("14 Voltios"); }} className={`px-3 py-1.5 rounded text-[9px] font-bold border transition ${selectedVoltage === 14 ? 'bg-yellow-900/50 border-yellow-500 text-yellow-100 shadow-[0_0_10px_rgba(234,179,8,0.3)]' : 'bg-slate-800 border-slate-700 text-slate-500 hover:bg-slate-700'}`}>14V</button>
                                            </div>
                                        </div>
                                    </div>

                            {/* SECCIÓN GARAJE COCHES AÑADIDA */}
                            {customCars.length > 0 && (
                                <div className="sidebar-section">
                                    <div className="sidebar-section-title flex justify-between items-center">
                                        <span className="text-purple-400">Garaje Coches</span>
                                        <span className="text-[9px] bg-slate-800 px-1.5 py-0.5 rounded text-slate-400 font-mono border border-slate-700">{customCars.length}</span>
                                    </div>
                                    <div className="flex flex-col gap-2 max-h-[200px] overflow-y-auto pr-1">
                                        {customCars.map(car => (
                                            <div key={car.id} className={`flex items-center justify-between p-2 rounded border transition-all ${selectedCarModelId === car.id ? 'bg-slate-800 border-purple-500 shadow-[0_0_10px_rgba(168,85,247,0.2)]' : 'bg-slate-900/40 border-slate-700 hover:bg-slate-800'}`}>
                                                <button onClick={() => { setSelectedCarModelId(car.id); speak(car.name); }} className="flex-1 text-left flex items-center gap-2 overflow-hidden group">
                                                    <CarFront size={12} className={selectedCarModelId === car.id ? 'text-purple-400' : 'text-slate-600 group-hover:text-purple-400 transition-colors'} />
                                                    <span className={`text-[9px] font-bold uppercase truncate ${selectedCarModelId === car.id ? 'text-purple-100' : 'text-slate-400 group-hover:text-white transition-colors'}`}>{car.name}</span>
                                                </button>
                                                <div className="flex gap-1 shrink-0 opacity-100">
                                                     <button onClick={(e) => { e.stopPropagation(); const newName = prompt("Nuevo nombre:", car.name); if(newName) renameCar(car.id, newName); }} className="p-1 hover:bg-yellow-900/30 rounded text-slate-500 hover:text-yellow-400 transition" title="Editar Nombre"><Edit size={12}/></button>
                                                     <button onClick={(e) => { e.stopPropagation(); setPreviewData({ type: 'CAR', subType: car.type, color: selectedLane === 1 ? '#ef4444' : '#3b82f6', obj: car.customData?.obj, mtl: car.customData?.mtl, tex: car.customData?.tex, name: car.name }); }} className="p-1 hover:bg-cyan-900/30 rounded text-slate-500 hover:text-cyan-400 transition" title="Ver 3D"><Eye size={12}/></button>
                                                     <button onClick={(e) => { e.stopPropagation(); deleteCustomItem('car', car.id); }} className="p-1 hover:bg-red-900/30 rounded text-slate-500 hover:text-red-400 transition" title="Eliminar"><Trash2 size={12}/></button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            <div className="sidebar-section border-none pb-20">
                                <div className="sidebar-section-title">Taller & Tuning</div>
                                <div className="bg-slate-900/50 p-2 rounded border border-slate-800 mb-2">
                                            <div className="flex justify-between items-center mb-1">
                                                <span className="text-[9px] font-bold text-slate-500 uppercase">Coche: {activeCarData.name}</span>
                                                {selectedCarModelId.startsWith('custom-') && (
                                                    <button onClick={() => deleteCustomItem('car', selectedCarModelId)} className="text-[8px] text-red-500 hover:text-red-400 bg-red-900/20 px-1 rounded border border-red-900/50"><Trash2 size={10}/></button>
                                                )}
                                            </div>
                                            <div className="flex gap-2 overflow-x-auto pb-2 scrollbar-hide snap-x">
                                                {allCars.map(car => (
                                                    <div key={car.id} onClick={() => setSelectedCarModelId(car.id)} className={`cursor-pointer snap-start min-w-[70px] p-1 rounded border flex flex-col items-center justify-center gap-1 transition relative group ${selectedCarModelId === car.id ? 'bg-slate-800 border-cyan-500' : 'border-slate-700 hover:bg-slate-800'}`}>
                                                        <div className="w-full h-5 bg-gray-700 rounded flex items-center justify-center text-[7px] text-white font-bold">{car.type.substring(0,3)}</div>
                                                        <button onClick={(e) => { e.stopPropagation(); setPreviewData({ type: 'CAR', subType: car.type, color: selectedLane === 1 ? '#ef4444' : '#3b82f6', obj: car.customData?.obj, mtl: car.customData?.mtl, tex: car.customData?.tex, name: car.name }); }} className="absolute top-0 right-0 p-1 bg-black/70 hover:bg-cyan-600 rounded-full text-white opacity-0 group-hover:opacity-100 transition-all z-10" title="Vista Previa 3D"><Eye size={10} /></button>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>

                                        <div className="bg-slate-900/50 p-3 rounded border border-slate-800 mb-4 shadow-[0_0_15px_rgba(0,255,255,0.05)]">
                                            <div className="flex items-center gap-2 border-b border-slate-700 pb-2 mb-2">
                                                <div className={`w-2 h-2 rounded-full ${importState.obj ? 'bg-green-400 animate-pulse' : 'bg-slate-600'}`}></div>
                                                <span className={`text-[10px] font-black uppercase tracking-widest ${importState.obj ? 'text-green-400' : 'text-slate-500'}`}>{importState.obj ? "VISTA PREVIA EN PISTA" : "LABORATORIO DE IMPORTACIÓN"}</span>
                                            </div>
                                            <input type="text" placeholder="Nombre del Bólido..." className="w-full bg-slate-800 border border-slate-600 rounded p-1.5 text-[10px] text-white mb-2 focus:border-cyan-500 outline-none font-bold" value={importState.name} onChange={(e) => setImportState(prev => ({...prev, name: e.target.value}))} />
                                            <div className="grid grid-cols-3 gap-1 mb-2">
                                                <input type="file" ref={objInputRef} onChange={(e) => handleImportFile('obj', e)} accept=".obj" className="hidden" />
                                                <button onClick={() => objInputRef.current.click()} className={`btn-tile h-10 flex-col gap-0 ${importState.obj ? 'border-green-500 text-green-400 bg-green-900/10' : 'bg-slate-800'}`} title="Cargar Modelo 3D"><Plus size={12}/><span className="btn-label mt-0">OBJ</span></button>
                                                <input type="file" ref={mtlInputRef} onChange={(e) => handleImportFile('mtl', e)} accept=".mtl" className="hidden" />
                                                <button onClick={() => mtlInputRef.current.click()} className={`btn-tile h-10 flex-col gap-0 ${importState.mtl ? 'border-green-500 text-green-400 bg-green-900/10' : 'bg-slate-800'}`} title="Cargar Materiales"><Upload size={12}/><span className="btn-label mt-0">MTL</span></button>
                                                <input type="file" ref={imgInputRef} onChange={(e) => handleImportFile('tex', e)} accept="image/png, image/jpeg" className="hidden" />
                                                <button onClick={() => imgInputRef.current.click()} className={`btn-tile h-10 flex-col gap-0 ${importState.tex ? 'border-green-500 text-green-400 bg-green-900/10' : 'bg-slate-800'}`} title="Cargar Textura/Skin"><ImageIcon size={12}/><span className="btn-label mt-0">PNG</span></button>
                                            </div>
                                            
                                            {importState.obj && (
                                                <div className="bg-black/40 p-2 rounded border border-slate-700/50 mb-2 space-y-2 animate-fade-in">
                                                    <div className="text-[7px] text-slate-500 uppercase font-bold text-center mb-1 border-b border-slate-800 pb-1">Ajuste de Posición (Coordenadas)</div>
                                                    <div className="flex flex-col"><div className="flex justify-between"><span className="text-[8px] font-bold text-slate-500">LONGITUDINAL (X)</span><span className="text-[8px] text-cyan-400">{activeCarData.specs?.offset?.x || 0}</span></div><input type="range" min="-10" max="10" step="0.1" value={activeCarData.specs?.offset?.x || 0} onChange={(e) => updateCarSpec('offset', { x: parseFloat(e.target.value) })} className="h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-cyan-500"/></div>
                                                    <div className="flex flex-col"><div className="flex justify-between"><span className="text-[8px] font-bold text-slate-500">ALTURA (Y)</span><span className="text-[8px] text-cyan-400">{activeCarData.specs?.offset?.y || 0}</span></div><input type="range" min="-5" max="10" step="0.1" value={activeCarData.specs?.offset?.y || 0} onChange={(e) => updateCarSpec('offset', { y: parseFloat(e.target.value) })} className="h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-cyan-500"/></div>
                                                    <div className="flex flex-col"><div className="flex justify-between"><span className="text-[8px] font-bold text-slate-500">LATERAL (Z)</span><span className="text-[8px] text-cyan-400">{activeCarData.specs?.offset?.z || 0}</span></div><input type="range" min="-5" max="5" step="0.1" value={activeCarData.specs?.offset?.z || 0} onChange={(e) => updateCarSpec('offset', { z: parseFloat(e.target.value) })} className="h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-cyan-500"/></div>
                                                    <div className="text-[7px] text-slate-500 uppercase font-bold text-center mb-1 mt-2 border-b border-slate-800 pb-1">Ajuste de Rotación</div>
                                                    <div className="flex flex-col"><div className="flex justify-between"><span className="text-[8px] font-bold text-yellow-500">CABECEO (X)</span><span className="text-[8px] text-yellow-400">{activeCarData.specs?.rotation?.x || 0}°</span></div><input type="range" min="-180" max="180" step="5" value={activeCarData.specs?.rotation?.x || 0} onChange={(e) => updateCarSpec('rotation', { x: parseInt(e.target.value) })} className="h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-yellow-500"/></div>
                                                    <div className="flex flex-col"><div className="flex justify-between"><span className="text-[8px] font-bold text-slate-500">DIRECCIÓN (Y)</span><span className="text-[8px] text-cyan-400">{activeCarData.specs?.rotation?.y || 0}°</span></div><input type="range" min="0" max="360" step="5" value={activeCarData.specs?.rotation?.y || 0} onChange={(e) => updateCarSpec('rotation', { y: parseInt(e.target.value) })} className="h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-cyan-500"/></div>
                                                    <div className="flex flex-col"><div className="flex justify-between"><span className="text-[8px] font-bold text-slate-500">VUELCO (Z)</span><span className="text-[8px] text-cyan-400">{activeCarData.specs?.rotation?.z || 0}°</span></div><input type="range" min="-180" max="180" step="5" value={activeCarData.specs?.rotation?.z || 0} onChange={(e) => updateCarSpec('rotation', { z: parseInt(e.target.value) })} className="h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-cyan-500"/></div>
                                                </div>
                                            )}
                                            <div className="flex gap-1 mt-2">
                                                <button onClick={saveImportedCar} className="btn-tile h-12 w-full bg-green-900/20 border-green-600 text-green-100 flex-row gap-2 hover:bg-green-800 hover:shadow-[0_0_15px_#22c55e]" title="Guardar configuración actual"><Save size={16}/><span className="btn-label mt-0 text-green-400 text-[10px]">GRABAR BÓLIDO</span></button>
                                            </div>
                                        </div>

                                        <div className="bg-slate-900/50 p-2 rounded border border-slate-800 mb-2">
                                            <div className="flex justify-between items-center mb-1"><span className="text-[9px] font-bold text-slate-500 uppercase">Motor: {selectedMotor.name}</span>{selectedMotor.id.startsWith('custom-') && (<button onClick={() => deleteCustomItem('motor', selectedMotor.id)} className="text-[8px] text-red-500 hover:text-red-400 bg-red-900/20 px-1 rounded border border-red-900/50"><Trash2 size={10}/></button>)}</div>
                                            <div className="flex gap-2 overflow-x-auto pb-2 scrollbar-hide">{motors.map(m => (<button key={m.id} onClick={() => setSelectedMotor(m)} className={`min-w-[50px] h-[50px] p-1 rounded border flex items-center justify-center transition ${selectedMotor.id === m.id ? 'bg-yellow-900/30 border-yellow-500 shadow-[0_0_10px_#eab308]' : 'border-slate-700 hover:bg-slate-800'}`}><div className="scale-75"><MotorIcon color={m.color} /></div></button>))}<button onClick={addMotor} className="min-w-[50px] h-[50px] rounded border border-dashed border-slate-600 flex flex-col items-center justify-center text-slate-500 hover:text-green-400 hover:border-green-500 transition"><Plus size={20}/></button></div>
                                        </div>
                                        <div className="bg-slate-900/50 p-2 rounded border border-slate-800 mb-2">
                                            <div className="flex justify-between items-center mb-1"><span className="text-[9px] font-bold text-slate-500 uppercase">Gomas: {selectedTire.name}</span>{selectedTire.id.startsWith('custom-') && (<button onClick={() => deleteCustomItem('tire', selectedTire.id)} className="text-[8px] text-red-500 hover:text-red-400 bg-red-900/20 px-1 rounded border border-red-900/50"><Trash2 size={10}/></button>)}</div>
                                            <div className="flex gap-2 overflow-x-auto pb-2 scrollbar-hide">{tires.map(t => (<button key={t.id} onClick={() => setSelectedTire(t)} className={`min-w-[50px] h-[50px] p-1 rounded border flex items-center justify-center transition ${selectedTire.id === t.id ? 'bg-blue-900/30 border-blue-500 shadow-[0_0_10px_#3b82f6]' : 'border-slate-700 hover:bg-slate-800'}`}><div className="scale-75"><TireIcon color={t.color} label={t.label} /></div></button>))}<button onClick={addTire} className="min-w-[50px] h-[50px] rounded border border-dashed border-slate-600 flex flex-col items-center justify-center text-slate-500 hover:text-green-400 hover:border-green-500 transition"><Plus size={20}/></button></div>
                                        </div>
                                        <div className="flex items-center gap-2 bg-slate-900/50 p-2 rounded border border-slate-800"><Weight size={14} className="text-blue-400"/><input type="range" min="60" max="140" step="1" value={carWeight} onChange={e=>setCarWeight(parseInt(e.target.value))} className="flex-1 h-1.5 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500"/><span className="text-[9px] font-mono text-blue-400 w-6 text-right">{carWeight}g</span></div>
                                    </div>
                                </>
                            )}
                        </div>
                    </div>

                    {/* MODALS */}
                    {confirmModal && (
                        <div className="absolute inset-0 z-[100] flex items-center justify-center bg-black/70 backdrop-blur-sm no-print animate-fade-in">
                            <div className="bg-slate-900 border border-slate-700 p-6 rounded-xl shadow-2xl max-w-sm w-full m-4 transform scale-100 transition-all">
                                <h3 className="text-xl font-bold text-white mb-2">{confirmModal.isAlert ? "Información" : "Confirmar Acción"}</h3>
                                <p className="text-slate-300 mb-6 font-medium">{confirmModal.message}</p>
                                <div className="flex gap-3 justify-end">
                                    {!confirmModal.isAlert && (<button onClick={() => setConfirmModal(null)} className="px-4 py-2 rounded bg-slate-700 hover:bg-slate-600 text-white font-bold transition">Cancelar</button>)}
                                    <button onClick={confirmModal.onConfirm} className="px-4 py-2 rounded bg-red-600 hover:bg-red-500 text-white font-bold transition shadow-lg">{confirmModal.isAlert ? "Entendido" : "Sí, continuar"}</button>
                                </div>
                            </div>
                        </div>
                    )}
                    {previewData && (<PreviewModal data={previewData} onClose={() => setPreviewData(null)} />)}
                    {showBoardConfig && (
                        <div className="absolute inset-0 z-[200] flex items-start justify-start no-print">
                            <div className="absolute inset-0 bg-black/60 backdrop-blur-[1px]"></div>
                            <div className="relative z-10 bg-slate-900 border border-slate-700 p-4 rounded-xl shadow-2xl w-[280px] ml-[360px] mt-2 animate-fade-in">
                                <h2 className="text-xs font-black text-white mb-3 text-center uppercase tracking-widest border-b border-slate-700 pb-2 flex items-center justify-center gap-2"><Ruler size={14} className="text-blue-500"/> Configuración Inicial</h2>
                                <div className="space-y-3">
                                    <div className="flex gap-2"><div><label className="block text-[9px] font-bold text-slate-400 uppercase mb-1">Largo (cm)</label><input type="number" value={inputSize.width} onChange={e=>setInputSize({...inputSize, width: e.target.value})} className="w-full bg-slate-800 border border-slate-600 rounded p-1.5 text-white text-sm font-bold text-center focus:border-blue-500 outline-none transition" /></div><div><label className="block text-[9px] font-bold text-slate-400 uppercase mb-1">Ancho (cm)</label><input type="number" value={inputSize.length} onChange={e=>setInputSize({...inputSize, length: e.target.value})} className="w-full bg-slate-800 border border-slate-600 rounded p-1.5 text-white text-sm font-bold text-center focus:border-blue-500 outline-none transition" /></div></div>
                                    <div><label className="block text-[9px] font-bold text-slate-400 uppercase mb-1">Sistema de Pista</label><div className="flex gap-1"><button onClick={()=>setCurrentSystem('ninco')} className={`flex-1 py-1.5 rounded text-[9px] font-bold border transition ${currentSystem === 'ninco' ? 'bg-red-900/50 border-red-500 text-white' : 'bg-slate-800 border-slate-600 text-slate-500 hover:bg-slate-700'}`}>NINCO 1:32</button><button onClick={()=>setCurrentSystem('scaleauto')} className={`flex-1 py-1.5 rounded text-[9px] font-bold border transition ${currentSystem === 'scaleauto' ? 'bg-yellow-900/50 border-yellow-500 text-white' : 'bg-slate-800 border-slate-600 text-slate-500 hover:bg-slate-700'}`}>SCALE 1:24</button></div></div>
                                    <button onClick={startBuilder} className="w-full bg-blue-600 hover:bg-blue-700 text-white font-black text-sm py-2 rounded transition shadow-lg border-b-2 border-blue-800 active:border-b-0 active:translate-y-0.5 mt-2 flex items-center justify-center gap-2">EMPEZAR <ArrowRight size={14}/></button>
                                </div>
                            </div>
                        </div>
                    )}
                    {viewMode === 'report' && (
                        <div className="report-view">
                            <div className="flex justify-between items-center w-full px-4 py-3 bg-white border-b border-gray-200 sticky top-0 z-10 no-print shadow-sm">
                                <button onClick={()=>setViewMode('editor')} className="flex items-center gap-2 bg-gray-200 text-gray-800 px-6 py-3 rounded hover:bg-gray-300 font-bold text-sm transition"><ArrowLeft size={18}/> VOLVER</button>
                                <button onClick={downloadPDF} className="flex items-center gap-2 bg-blue-600 text-white px-6 py-3 rounded hover:bg-blue-700 font-bold text-sm shadow transition"><FileDown size={18}/> DESCARGAR PDF</button>
                            </div>
                            <div id="printable-area" className="bg-white">
                                <div className="report-header" style={currentSystem === 'scaleauto' ? { background: '#475569', color: '#fbbf24', borderBottom: '4px solid #fbbf24' } : {}}>{systemSpecs.name} <span className="text-sm opacity-70 font-normal">INFORME</span></div>
                                <div className="report-content"><div className="flex flex-col w-full h-full bg-white gap-4 p-4"><div className="snapshot-wrapper"><div className="snapshot-container">{snapshotUrl && <img src={snapshotUrl} alt="Circuito" className="snapshot-img" />}</div></div><div className="flex flex-col md:flex-row w-full gap-6"><div className="flex-1 p-3 border border-gray-200 rounded bg-gray-50"><h3 className="font-black text-lg mb-2 text-red-700 uppercase border-b-2 border-red-200 pb-1">Resumen</h3><div className="text-slate-800 flex flex-col gap-2"><div className="flex justify-between items-center text-base"><span>Cuerda Total:</span> <span className="font-bold text-xl">{stats.totalLen} m</span></div></div></div><div className="flex-[1.5]"><h3 className="font-black text-lg mb-2 text-red-700 uppercase border-b-2 border-red-200 pb-1">Inventario</h3><table className="inv-table w-full text-slate-800 border border-gray-200"><thead><tr><th>Pieza</th><th className="text-center">Cant.</th></tr></thead><tbody>{stats.inventory.map(([name, count], i) => (<tr key={i}><td className="font-medium">{name}</td><td className="text-center font-bold bg-white">{count}</td></tr>))}<tr className="bg-gray-200 border-t-2 border-gray-400"><td className="font-black text-right text-gray-800">TOTAL</td><td className="text-center font-black text-black text-lg">{stats.totalPieces}</td></tr></tbody></table></div></div></div></div></div></div>
                    )}

                    {/* CANVAS AREA */}
                    <div className={`canvas-area ${viewMode==='report' ? 'hidden' : ''}`}>
                        <Canvas shadows dpr={[1, 2]} gl={{ antialias: true, preserveDrawingBuffer: true }}>
                            <PerspectiveCamera makeDefault fov={appMode === 'builder' ? 20 : 45} />
                            <OrbitControls makeDefault minDistance={10} maxDistance={3000} target={[0,0,0]} enabled={viewMode==='editor'} enableRotate={appMode === 'racer'} enableZoom={appMode === 'racer'} maxPolarAngle={appMode === 'racer' ? Math.PI / 2 - 0.1 : 0} />
                            <SceneManager appMode={appMode} viewMode={viewMode} setViewMode={setViewMode} onCaptureReady={handleCaptureReady} boardRef={boardRef} boardSize={boardSize} />
                            <CameraEventsListener enabled={appMode === 'builder'} />
                            <ambientLight intensity={0.7} />
                            <directionalLight position={[100, 200, 50]} intensity={1.5} castShadow />
                            <ErrorBoundary fallback={null}>
                                <Environment preset="city" />
                            </ErrorBoundary>
                            <group>
                                {boardSize.width > 0 && (<DraggableBoard ref={boardRef} width={boardSize.width} length={boardSize.length} enabled={moveMode === 'board' && viewMode === 'editor' && appMode === 'builder'} isDecoMode={decoMode} onBoardClick={decoMode ? placeDecoration : null} />)}
                                {chain.map((s) => { if (s.type === 'START') { return ( <StartPieceHandler key={s.id} id={s.id} position={s.pos} onPosChange={updateStartPos} isSelected={selId === s.id && viewMode === 'editor' && appMode === 'builder' && !decoMode} enabled={viewMode === 'editor' && appMode === 'builder'} dragEnabled={moveMode === 'track' && viewMode === 'editor' && appMode === 'builder'}> <group rotation={s.rot}> <TrackMesh def={piecesDef[s.pId]} isLeft={s.dir === 1} isSelected={selId === s.id && viewMode==='editor' && appMode === 'builder' && !decoMode} onClick={(e) => handlePieceClick(e, s.id)} systemSpecs={systemSpecs} hasFence={s.showFence !== false} /> <FinishLine width={systemSpecs.width} /> </group> </StartPieceHandler> ); } return ( <group key={s.id} position={s.pos} rotation={s.rot}> <TrackMesh def={piecesDef[s.pId]} isLeft={s.dir === 1} isSelected={selId === s.id && viewMode==='editor' && appMode === 'builder' && !decoMode} onClick={(e) => handlePieceClick(e, s.id)} systemSpecs={systemSpecs} hasFence={s.showFence !== false} /> </group> ); })}
                                {viewMode==='editor' && appMode === 'builder' && !decoMode && (<group position={new THREE.Vector3().setFromMatrixPosition(pointerMatrix)} quaternion={new THREE.Quaternion().setFromRotationMatrix(pointerMatrix)}><mesh position={[0,1,0]}><coneGeometry args={[1, 2, 8]} /><meshBasicMaterial color="#22c55e" /></mesh></group>)}
                                {placedDecos.map(d => { let modelInfo = customDecos.find(c => c.id === d.modelId); if (!modelInfo) modelInfo = BASE_DECOS.find(b => b.id === d.modelId); return ( <DraggableDecoration key={d.instanceId} data={d} modelInfo={modelInfo} isSelected={selectedDecoInstance === d.instanceId} isDecoMode={decoMode} onUpdate={updateDecoInstance} onSelect={setSelectedDecoInstance} /> ); })}
                                {carEnabled && chain.length > 0 && viewMode === 'editor' && (
                                    <AnimatedCar tracks={tracks} throttle={carThrottle} isPlaying={raceState !== 'paused' && raceState !== 'countdown' && raceState !== 'finished'} isPaused={raceState === 'paused'} selectedLane={selectedLane} onLap={handleLap} motor={selectedMotor} tires={selectedTire} voltage={selectedVoltage} weight={carWeight} onDerail={handleDerail} driveMode={driveMode} onTelemetry={handleTelemetry} totalLaps={targetLaps} systemId={currentSystem} resetToken={resetToken} carModelId={selectedCarModelId} carType={activeCarData.type} customData={activeCarData?.customData} modelRotation={activeCarData?.specs?.rotation?.y || 0} modelRotationZ={activeCarData?.specs?.rotation?.z || 0} modelRotationX={activeCarData?.specs?.rotation?.x || 0} offsetY={activeCarData?.specs?.offset?.y || 0} offsetZ={activeCarData?.specs?.offset?.z || 0} offsetX={activeCarData?.specs?.offset?.x || 0} />
                                )}
                            </group>
                        </Canvas>

                        <TouchControlsOverlay enabled={appMode === 'builder' && viewMode === 'editor'} />

                        {carEnabled && viewMode === 'editor' && appMode === 'racer' && (
                            <>
                                <div className="absolute top-0 left-0 w-full flex flex-col z-40 p-4 items-center pointer-events-none">
                                    <div className="flex justify-between items-stretch gap-0 neon-panel-full p-0 rounded-xl overflow-hidden w-full max-w-3xl shadow-2xl">
                                        <div className="flex flex-col flex-1 min-w-[180px] p-3 bg-gradient-to-r from-slate-900/80 to-transparent justify-center">
                                            <div className="flex items-center gap-2 mb-2 border-b border-cyan-500/30 pb-1"><Activity size={14} className="text-cyan-400 animate-pulse"/><span className="text-[10px] font-black text-cyan-400 uppercase tracking-widest drop-shadow-[0_0_5px_cyan]">VELOCIDAD</span></div>
                                            <div className="relative w-full h-4 bg-slate-900 rounded border border-slate-700 mb-3 group"><div style={{width: `${Math.min(100, (telemetry.limit/25)*100)}%`}} className="absolute top-0 left-0 h-full bg-red-900/20 border-r border-red-500/50 transition-all duration-300"></div><div style={{width: `${Math.min(100, (telemetry.speed/25)*100)}%`}} className={`absolute top-0 left-0 h-full transition-all duration-75 shadow-[0_0_10px_cyan] ${telemetry.speed > telemetry.limit ? 'bg-red-500 shadow-[0_0_15px_red]' : 'bg-cyan-400'}`}></div><span className="absolute inset-0 flex items-center justify-center text-[10px] font-black text-white mix-blend-difference z-10 font-mono tracking-wider">{telemetry.speed.toFixed(1)} KM/H</span></div>
                                            <div className="grid grid-cols-2 gap-2 mt-auto"><div className="bg-slate-800/50 rounded p-1 flex flex-col items-center border border-slate-700"><span className="text-[8px] text-slate-500 font-bold">FUERZA G</span><span className="text-sm font-mono font-bold text-white">{telemetry.gForce.toFixed(2)}G</span></div><div className="bg-slate-800/50 rounded p-1 flex flex-col items-center border border-slate-700"><span className="text-[8px] text-slate-500 font-bold">AGARRE</span><span className={`text-sm font-mono font-bold ${telemetry.gripLimit > 90 ? 'text-red-500 animate-pulse' : 'text-white'}`}>{telemetry.gripLimit.toFixed(0)}%</span></div></div>
                                        </div>
                                        <div className="w-px bg-gradient-to-b from-transparent via-cyan-500/50 to-transparent"></div>
                                        <div className="flex-[1.2] flex flex-col items-center p-2 relative bg-black/20">
                                            <div className="flex gap-3 bg-black/90 px-6 py-2 rounded-b-xl border-x border-b border-slate-700/50 shadow-lg mb-2">
                                                {[1, 2, 3, 4, 5].map(i => (<div key={i} className={`w-5 h-5 rounded-full transition-all duration-75 border border-slate-600 ${lightStep >= 6 ? 'bg-green-500 shadow-[0_0_15px_#22c55e]' : (lightStep >= i ? 'bg-red-600 shadow-[0_0_15px_#ef4444]' : 'bg-slate-900')}`}></div>))}
                                            </div>
                                            <div onClick={cycleLaps} className="flex flex-col items-center justify-center flex-1 cursor-pointer group hover:bg-white/5 rounded-xl transition-all w-full pointer-events-auto pb-1" title="Clic para cambiar vueltas objetivo">
                                                <div className="flex items-center gap-2 mb-1">
                                                    <span className="text-[10px] font-bold text-slate-500 tracking-[0.4em] uppercase group-hover:text-cyan-400 transition-colors">VUELTA</span>
                                                    <RefreshCw size={10} className="text-slate-600 group-hover:text-cyan-400 opacity-0 group-hover:opacity-100 transition-all"/>
                                                </div>
                                                <div className="flex items-baseline leading-none select-none">
                                                    <span className="text-6xl font-black text-white italic tracking-tighter drop-shadow-[0_4px_0_rgba(0,0,0,0.5)]" style={{fontFamily:'Arial Black, sans-serif'}}>{raceData.currentLap}</span>
                                                    <span className="text-xl font-bold text-slate-600 group-hover:text-white transition-colors">/{targetLaps===Infinity?'∞':targetLaps}</span>
                                                </div>
                                                <div className="mt-2 px-3 py-0.5 bg-cyan-900/30 border border-cyan-500/30 rounded text-[9px] font-bold text-cyan-200 uppercase tracking-wider">{telemetry.section || "PISTA"}</div>
                                            </div>
                                            {isCrashed && (<div className="absolute inset-0 bg-red-900/80 flex items-center justify-center backdrop-blur-sm z-50 animate-pulse"><span className="text-white font-black text-xl tracking-widest border-4 border-white px-4 py-2 transform -rotate-6">CRASH!</span></div>)}
                                        </div>
                                        <div className="w-px bg-gradient-to-b from-transparent via-cyan-500/50 to-transparent"></div>
                                        <div className="flex flex-col flex-1 min-w-[180px] p-3 bg-gradient-to-l from-slate-900/80 to-transparent justify-center">
                                            <div className="flex items-center justify-end gap-2 mb-2 border-b border-cyan-500/30 pb-1"><span className="text-[10px] font-black text-cyan-400 uppercase tracking-widest drop-shadow-[0_0_5px_cyan]">TIEMPOS</span><Clock size={14} className="text-cyan-400"/></div>
                                            <div className="flex flex-col gap-1.5 w-full"><div className="flex justify-between items-center bg-slate-800/30 px-2 py-1 rounded"><span className="text-[9px] font-bold text-slate-400">TOTAL</span><span className="font-mono font-bold text-white text-sm">{formatTime(raceData.totalTime)}</span></div><div className="flex justify-between items-center bg-slate-800/30 px-2 py-1 rounded"><span className="text-[9px] font-bold text-yellow-500">MEJOR</span><span className="font-mono font-bold text-yellow-400 text-sm">{raceData.bestLap > 0 ? raceData.bestLap.toFixed(3) : '--.---'}</span></div><div className="flex justify-between items-center bg-slate-800/30 px-2 py-1 rounded"><span className="text-[9px] font-bold text-slate-400">ÚLTIMA</span><span className="font-mono font-bold text-slate-300 text-sm">{raceData.lastLapTime > 0 ? raceData.lastLapTime.toFixed(3) : '--.---'}</span></div><div className="flex justify-between items-center bg-slate-800/30 px-2 py-1 rounded border-l-2 border-blue-500"><span className="text-[9px] font-bold text-blue-400">MEDIA</span><span className="font-mono font-bold text-blue-200 text-sm">{raceData.avgLap > 0 ? raceData.avgLap.toFixed(3) : '--.---'}</span></div></div>
                                        </div>
                                    </div>
                                </div>
                                <div className="pointer-events-auto bg-black/80 backdrop-blur border-t border-slate-700 p-2 pb-safe flex gap-3 items-center absolute bottom-0 left-0 w-full z-50">
                                    <div className="flex items-center gap-2 flex-1 h-20"> 
                                        <button onClick={() => !isCrashed && driveMode === 'manual' && setCarThrottle(t => Math.max(0, parseFloat((t - 0.1).toFixed(1))))} disabled={driveMode === 'ai'} className="w-20 h-full rounded bg-slate-800 hover:bg-slate-700 text-white z-30 flex items-center justify-center border border-slate-600 font-bold active:scale-95 transition shadow-lg"><Minus size={32} /></button>
                                        <div className="flex-1 h-full bg-slate-900 rounded-lg border border-slate-700 relative overflow-hidden mx-1"><div className="absolute inset-0 z-0 flex justify-between px-4 opacity-20 pointer-events-none">{[...Array(9)].map((_,i)=><div key={i} className="w-px h-full bg-white"></div>)}</div><div className="absolute inset-0 bg-gradient-to-r from-orange-900/60 to-red-600/60 z-0 origin-left transition-transform duration-75" style={{transform: `scaleX(${carThrottle})`}}></div><input type="range" min="0" max="1" step="0.1" value={carThrottle} disabled={driveMode === 'ai'} onChange={(e) => !isCrashed && driveMode === 'manual' && setCarThrottle(parseFloat(e.target.value))} className={`absolute inset-0 w-full h-full opacity-0 cursor-pointer z-20`}/><div className="absolute inset-0 flex flex-col items-center justify-center pointer-events-none z-10"><span className="text-[10px] font-bold text-slate-400 uppercase leading-none mb-1">THROTTLE</span><span className={`text-4xl font-black leading-none ${driveMode === 'ai' ? 'text-blue-400' : 'text-orange-400'}`}>{driveMode === 'ai' ? 'AUTO' : `${(carThrottle * 100).toFixed(0)}%`}</span></div></div>
                                        <button onClick={() => !isCrashed && driveMode === 'manual' && setCarThrottle(t => Math.min(1, parseFloat((t + 0.1).toFixed(1))))} disabled={driveMode === 'ai'} className="w-20 h-full rounded bg-slate-800 hover:bg-slate-700 text-white z-30 flex items-center justify-center border border-slate-600 font-bold active:scale-95 transition shadow-lg"><Plus size={32} /></button>
                                    </div>
                                </div>
                            </>
                        )}
                        
                    </div>
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
