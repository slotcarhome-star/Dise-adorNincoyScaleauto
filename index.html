<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Slot Track Manager - Ninco & Scaleauto</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "three": "https://esm.sh/three@0.161.0",
            "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?external=react,react-dom,three",
            "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber",
            "lucide-react": "https://esm.sh/lucide-react@0.344.0?external=react",
            "three/examples/jsm/loaders/OBJLoader": "https://esm.sh/three@0.161.0/examples/jsm/loaders/OBJLoader.js",
            "three/examples/jsm/loaders/MTLLoader": "https://esm.sh/three@0.161.0/examples/jsm/loaders/MTLLoader.js",
            "idb-keyval": "https://esm.sh/idb-keyval@6.2.1"
        }
    }
    </script>

    <style>
        /* LAYOUT FIX NUCLEAR: 100dvh es la clave para que no se corte en móviles/tablets */
        html, body { 
            height: 100dvh; /* Altura dinámica del viewport */
            width: 100vw;
            margin: 0; 
            padding: 0;
            overflow: hidden; 
            background-color: #050505; 
            color: white; 
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            touch-action: none; 
            position: fixed; 
            inset: 0;
            overscroll-behavior: none; 
        }
        
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            overflow: hidden; 
            position: relative;
        }

        #root {
            height: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
        }

        /* ... existing header styles ... */
        .ninco-header { background: #cc0000; color: white; padding: 12px; text-align: center; font-weight: 900; font-size: 24px; letter-spacing: -1px; text-transform: uppercase; border-bottom: 2px solid #990000; flex-shrink: 0; box-shadow: 0 4px 6px rgba(0,0,0,0.3); z-index: 60; display: flex; justify-content: center; align-items: center; position: relative; }
        .scaleauto-header { background: #475569; color: #fbbf24; border-bottom: 2px solid #fbbf24; }
        
        .tab-bar { display: flex; background: #0f0f13; border-bottom: 1px solid #333; flex-shrink: 0; z-index: 55; position: relative; }
        .tab-btn { flex: 1; padding: 12px; text-align: center; font-weight: 800; font-size: 14px; text-transform: uppercase; color: #64748b; cursor: pointer; transition: all 0.2s; border-bottom: 3px solid transparent; display: flex; align-items: center; justify-content: center; gap: 8px; }
        .tab-btn:hover { background: #1e1e24; color: #94a3b8; }
        .tab-btn.active { color: white; background: #1a1a20; border-bottom-color: #cc0000; }
        
        /* HUD FIXED: Anclado al fondo real visible */
        .hud { 
            background: #1a1a20; 
            border-top: 1px solid #333; 
            padding: 10px;
            
            /* Padding seguro + extra para evitar toques fantasma en la barra inferior */
            padding-bottom: calc(20px + env(safe-area-inset-bottom));
            
            position: fixed; /* FIXED es necesario para UI overlays */
            bottom: 0;
            left: 0;
            right: 0;
            
            z-index: 99999; 
            
            display: flex; 
            flex-direction: column; 
            gap: 8px; 
            align-items: flex-start; 
            justify-content: flex-end;
            
            transition: transform 0.3s ease-in-out; 
            width: 100%;
            height: auto; 
            max-height: 45vh;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.9);
            touch-action: pan-y; 
        }
        .hud.hidden-hud { transform: translateY(100%); }

        /* ... existing scroll styles ... */
        .hud-row {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 8px;
            width: 100%;
            overflow-x: auto;
            white-space: nowrap;
            padding-bottom: 4px; 
            -webkit-overflow-scrolling: touch; 
            flex-shrink: 0;
        }
        .hud-row::-webkit-scrollbar { display: none; }
        .hud-row { -ms-overflow-style: none; scrollbar-width: none; }

        .btn-tile { position: relative; display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 6px; background-color: #2d3748; border: 1px solid #4a5568; transition: all 0.1s; height: 55px; min-width: 55px; cursor: pointer; user-select: none; flex-shrink: 0; }
        .btn-tile:hover { background-color: #4a5568; border-color: #a0aec0; transform: translateY(-1px); }
        .btn-tile:active { transform: scale(0.95); }
        .btn-tile.active-tool { background-color: #166534; border-color: #22c55e; color: white; }
        .btn-tile.active-tool .btn-label { color: white; }
        
        .btn-label { font-size: 10px; font-weight: 700; text-transform: uppercase; margin-top: 3px; color: #cbd5e0; }
        .btn-tile:hover .btn-label { color: #fff; }
        .btn-new-circuit { display: flex; flex-direction: column; align-items: center; justify-content: center; background: #1e3a8a; border: 1px solid #3b82f6; color: white; border-radius: 6px; height: 55px; padding: 0 10px; cursor: pointer; min-width: 80px; }
        .btn-new-circuit:hover { background: #2563eb; }
        .btn-new-circuit span { font-size: 9px; font-weight: bold; margin-top: 2px; }
        .icon-curve { width: 22px; height: 22px; border-top: 4px solid #94a3b8; border-right: 4px solid #94a3b8; margin-top: 2px; margin-right: 2px; }
        .icon-straight { width: 6px; height: 20px; border-radius: 2px; background: #94a3b8; transform: rotate(90deg); }
        .r1-css { border-color: #ef4444; } .r2-css { border-color: #22c55e; } .r3-css { border-color: #eab308; } .r4-css { border-color: #3b82f6; } .r5-css { border-color: #6366f1; }
        .icon-cross { position: relative; width: 14px; height: 22px; }
        .icon-cross::before, .icon-cross::after { content:''; position: absolute; width: 3px; height: 22px; background: #94a3b8; left: 5px; }
        .icon-cross::before { transform: rotate(15deg); } .icon-cross::after { transform: rotate(-15deg); }
        .icon-power { width: 8px; height: 18px; background: #ef4444; border-radius: 1px; border: 1px solid #991b1b; }
        
        /* ... existing report styles ... */
        .report-view { position: absolute; inset: 0; background: white; z-index: 200; overflow-y: auto; display: flex; flex-direction: column; font-family: Arial, Helvetica, sans-serif !important; }
        .report-header { background: #cc0000; color: white; padding: 15px; text-align: center; font-weight: 900; font-size: 28px; letter-spacing: -1px; text-transform: uppercase; border-bottom: 4px solid #990000; flex-shrink: 0; }
        .report-content { width: 100%; max-width: 1000px; margin: 0 auto; display: flex; flex-direction: column; flex: 1; padding: 10px; gap: 10px; }
        .inv-table { width: 100%; border-collapse: collapse; font-size: 14px; margin-bottom: 0; font-family: Arial, Helvetica, sans-serif; }
        .inv-table th { background: #e5e7eb; padding: 8px; text-align: left; border-bottom: 2px solid #666; text-transform: uppercase; font-size: 12px; color: #111; font-weight: 900; }
        .inv-table td { padding: 6px 8px; border-bottom: 1px solid #ddd; color: #333; }
        .inv-table tr:nth-child(even) { background: #f3f4f6; }
        .snapshot-wrapper { display: flex; justify-content: center; width: 100%; margin-bottom: 10px; }
        .snapshot-container { border: 4px solid #16a34a; padding: 2px; background: #fff; display: inline-block; border-radius: 4px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
        .snapshot-img { max-width: 100%; height: auto; max-height: 50vh; display: block; }

        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #ffffff; border: 2px solid #ef4444; cursor: pointer; margin-top: -6px; box-shadow: 0 1px 3px rgba(0,0,0,0.4); transition: transform 0.1s; }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.1); }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #4b5563; border-radius: 2px; }
        
        /* TABLET & MOBILE FIX: Controles centrados verticalmente a la derecha */
        .touch-controls {
            position: fixed; 
            top: 50%; 
            right: 15px; 
            transform: translateY(-50%); /* Centrado vertical perfecto */
            bottom: auto; /* IMPORTANTE: Desvincular del fondo */
            
            display: flex; 
            flex-direction: column; 
            gap: 12px; 
            align-items: flex-end; 
            z-index: 1000; 
            pointer-events: auto;
        }
        .touch-btn {
            width: 50px; height: 50px; border-radius: 50%; background: #1e293b; border: 2px solid #64748b; color: white; display: flex; align-items: center; justify-content: center; box-shadow: 0 6px 10px rgba(0,0,0,0.5); cursor: pointer; transition: all 0.1s;
        }
        .touch-btn:active { transform: scale(0.95); background: #3b82f6; border-color: white; }
        .touch-pad-btn {
            width: 45px; height: 45px; background: #334155; border: 1px solid #475569; border-radius: 8px; color: white; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .touch-pad-btn:active { background: #3b82f6; transform: scale(0.95); }

        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        
        /* ... existing rest of styles ... */
        .neon-title-blur {
            color: #ffffff;
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #ffaaaa, 0 0 40px #ff5555, 0 0 55px #ff0000, 0 0 75px #ff0000;
            font-weight: 900;
            letter-spacing: 3px;
        }
        
        .neon-panel-full {
            border: 2px solid #06b6d4;
            box-shadow: 0 0 5px #06b6d4, 0 0 20px rgba(6, 182, 212, 0.4), inset 0 0 30px rgba(6, 182, 212, 0.15);
            background: rgba(10, 10, 15, 0.9);
            backdrop-filter: blur(10px);
        }
        
        .neon-separator { border-right: 1px solid rgba(6, 182, 212, 0.3); box-shadow: 1px 0 0 rgba(0,0,0,0.5); }
        @keyframes slide-up { from { transform: translateY(100%); } to { transform: translateY(0); } }
        .animate-slide-up { animation: slide-up 0.3s ease-out forwards; }
        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
        
        @keyframes fade-in { from { opacity: 0; } to { opacity: 1; } }
        .animate-fade-in { animation: fade-in 0.2s ease-out forwards; }

        /* Error Overlay Style */
        #error-overlay { display: none; position: fixed; inset: 0; background: #0f0f13; color: #ef4444; z-index: 9999; padding: 20px; font-family: monospace; overflow: auto; }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }

        @media print {
            .ninco-header, .scaleauto-header, .tab-bar, .hud, .touch-controls, .no-print { display: none !important; }
            /* FIX IMPRESIÓN: Liberar restricciones del contenedor principal para que salga todo el papel */
            html, body, #root, .app-container { position: static !important; overflow: visible !important; height: auto !important; }
            .report-view { position: static; display: block; height: auto; overflow: visible; z-index: auto; }
            .report-content { padding: 0; margin: 0; max-width: 100%; }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <div id="error-overlay">
        <h2 style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">Error de Inicio</h2>
        <p>Hubo un problema al cargar la aplicación. Esto suele ocurrir si la red bloquea las librerías CDN.</p>
        <pre id="error-message" style="background: #1e1e1e; padding: 10px; border-radius: 5px; margin-top: 10px; color: #f87171; white-space: pre-wrap;"></pre>
    </div>

    <script>
        window.onerror = function(message, source, lineno, colno, error) {
            const overlay = document.getElementById('error-overlay');
            const msgBox = document.getElementById('error-message');
            overlay.style.display = 'block';
            msgBox.textContent = `${message}\n\nEn: ${source}:${lineno}:${colno}`;
            console.error(error);
        };
    </script>

    <script type="text/babel" data-type="module">
        import React, { useState, useMemo, useRef, useEffect, useCallback, Suspense } from 'react';
        import { createRoot } from 'react-dom/client';
        import { Canvas, useThree, useFrame, useLoader } from '@react-three/fiber';
        import { OrbitControls, PerspectiveCamera, Environment, Center, Line, Text, Grid, Stage } from '@react-three/drei';
        import * as THREE from 'three';
        import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader';
        import { MTLLoader } from 'three/examples/jsm/loaders/MTLLoader';
        import { get, set } from 'idb-keyval'; 
        import { 
            Trash2, Undo2, ArrowLeftRight, RotateCcw, Zap, Ruler, Lock, Unlock, Move, 
            RotateCw, Scan, FileText, Printer, ArrowLeft, Droplet, FileDown, Home, 
            CopyPlus, Plus, CarFront, Play, Pause, Settings2, Gauge, AlertTriangle, 
            Flag, Timer, Trophy, Check, Battery, Disc, PenTool, LayoutTemplate, 
            ZoomIn, ZoomOut, ArrowUp, ArrowDown, ArrowRight, X, Minus, Weight,
            Bot, User, Activity, StopCircle, RefreshCw, Clock, Save, FolderOpen,
            Move3d, MousePointer2, PlayCircle, StopCircle as StopIcon, Truck, History, Upload, FileBox,
            Database, TreePine, Trees, BoxSelect, Eye, Image as ImageIcon
        } from 'lucide-react';

        // --- SISTEMAS DE PISTA ---
        const TRACK_SYSTEMS = {
            ninco: {
                id: 'ninco',
                name: 'NINCO',
                width: 18, 
                laneSpacing: 9, 
                railOffset: 4.5,
                railGap: 0.25,
                color: '#1a1a1a', 
                gripFactor: 1.0, 
                headerClass: 'ninco-header',
                r1: 24.137, 
                speedScale: 1.0
            },
            scaleauto: {
                id: 'scaleauto',
                name: 'SCALEAUTO',
                width: 20, 
                laneSpacing: 10, 
                railOffset: 5.0,
                railGap: 0.3, 
                color: '#64748b', 
                gripFactor: 0.8, 
                headerClass: 'ninco-header scaleauto-header',
                r1: 26.0, 
                speedScale: 1.1 
            }
        };

        const MAGNET_FORCE = 25.0; 
        
        // --- COCHES DISPONIBLES (GARAJE PREDEFINIDO) ---
        const PRESET_CARS = [
            { id: 'gt3_red', name: 'GT3 Rosso', type: 'STD', color: '#dc2626', specs: { offset: {x:0, y:0, z:0}, rotation: {y:0, z:0} }, description: 'Competición' },
            { id: 'gt3_blue', name: 'GT3 Blu', type: 'STD', color: '#2563eb', specs: { offset: {x:0, y:0, z:0}, rotation: {y:0, z:0} }, description: 'Equipo Oficial' },
            { id: 'lmp_yellow', name: 'LMP1 Speed', type: 'STD', color: '#eab308', specs: { offset: {x:0, y:0, z:0}, rotation: {y:0, z:0} }, description: 'Resistencia' },
            { id: 'rally_green', name: 'Rally X', type: 'STD', color: '#16a34a', specs: { offset: {x:0, y:0, z:0}, rotation: {y:0, z:0} }, description: 'Off-road' },
            { id: 'classic_white', name: 'Classic 911', type: 'STD', color: '#e2e8f0', specs: { offset: {x:0, y:0, z:0}, rotation: {y:0, z:0} }, description: 'Clásico' },
            { id: 'truck_black', name: 'Thunder Truck', type: 'TRUCK', color: '#1a1a1a', specs: { offset: {x:0, y:0.5, z:0}, rotation: {y:0, z:0} }, description: 'Camión' }
        ];

        // --- DECORACIONES DISPONIBLES (BASE) ---
        const BASE_DECOS = [
            { id: 'cube', name: 'Caja Test', type: 'BASIC_CUBE' }
        ];

        const INITIAL_MOTORS = [
            { id: 'nc8', name: 'NC-8 Thruster', rpm: 16000, torque: 0.8, color: '#fbbf24' },
            { id: 'nc5', name: 'NC-5 Speeder', rpm: 20000, torque: 1.0, color: '#ef4444' },
            { id: 'nc6', name: 'NC-6 Crusher', rpm: 23500, torque: 1.2, color: '#a855f7' },
            { id: 'nc10', name: 'NC-10 Exceeder', rpm: 26000, torque: 1.4, color: '#3b82f6' }
        ];
        const INITIAL_TIRES = [
            { id: 'soft', name: 'Blandos', grip: 1.25, color: '#f87171', label: 'SOFT' },
            { id: 'med',  name: 'Medios',  grip: 1.0,  color: '#facc15', label: 'MED' },
            { id: 'hard', name: 'Duros',   grip: 0.85, color: '#94a3b8', label: 'HARD' }
        ];
        const VOLTAGES = [12, 14];
        const LAP_OPTIONS = [10, 20, 30, 40, 50, Infinity];

        const getPieces = (system) => {
            const { width, r1, railOffset } = system;
            const halfW = width / 2;
            const R1_VAL = r1 - halfW;
            const R2_VAL = (r1 + width) - halfW;
            const R3_VAL = (r1 + width * 2) - halfW;
            const R4_VAL = (r1 + width * 3) - halfW;
            const R5_VAL = (r1 + width * 4) - halfW;

            return {
                'STD':  { id:'STD',  label:'Recta 40cm', type:'STRAIGHT', len:40 },
                'CONEX':{ id:'CONEX', label:'Conexiones', type:'STRAIGHT', len:40, isPower: true },
                'HALF': { id:'HALF', label:'Media 20cm', type:'STRAIGHT', len:20 },
                'QTR':  { id:'QTR',  label:'Cuarto 10cm', type:'STRAIGHT', len:10 },
                'XO':   { id:'XO',   label:'Cruce', type:'STRAIGHT', len:40, isCross: true },
                'R1':   { id:'R1',  label:'Curva R1', type:'CURVE', r:R1_VAL, ang:45,    col:'#ef4444' }, 
                'R2':   { id:'R2',  label:'Curva R2', type:'CURVE', r:R2_VAL, ang:45,    col:'#22c55e' }, 
                'R3':   { id:'R3',  label:'Curva R3', type:'CURVE', r:R3_VAL, ang:22.5,  col:'#eab308' }, 
                'R4':   { id:'R4',  label:'Curva R4', type:'CURVE', r:R4_VAL, ang:22.5,  col:'#3b82f6' }, 
                'R5':   { id:'R5',  label:'Curva R5', type:'CURVE', r:R5_VAL, ang:11.25, col:'#6366f1' }, 
                'R1H':  { id:'R1H', label:'Media R1/2', type:'CURVE', r:R1_VAL, ang:22.5,  col:'#ef4444', isHalf:true },
                'R2H':  { id:'R2H', label:'Media R2/2', type:'CURVE', r:R2_VAL, ang:22.5,  col:'#22c55e', isHalf:true },
            };
        };

        const MotorIcon = ({ color }) => (
            <svg width="40" height="40" viewBox="0 0 100 100" className="opacity-90">
                <rect x="20" y="25" width="60" height="50" rx="5" fill="#334155" stroke={color} strokeWidth="3" />
                <rect x="15" y="35" width="5" height="30" fill="#94a3b8" />
                <rect x="80" y="35" width="5" height="30" fill="#94a3b8" />
                <rect x="90" y="45" width="10" height="10" fill="#cbd5e1" />
                <path d="M40 25 L40 75 M60 25 L60 75" stroke="#475569" strokeWidth="2" />
                <text x="50" y="55" textAnchor="middle" fill={color} fontSize="14" fontWeight="bold">NC</text>
            </svg>
        );

        const TireIcon = ({ color, label }) => (
            <svg width="40" height="40" viewBox="0 0 100 100" className="opacity-90">
                <circle cx="50" cy="50" r="40" fill="#1a1a1a" stroke={color} strokeWidth="3" />
                <circle cx="50" cy="50" r="25" fill="#333" stroke="#555" strokeWidth="1" />
                <path d="M50 10 L50 30 M50 70 L50 90 M90 50 L70 50 M30 50 L10 50" stroke="#222" strokeWidth="4" />
                <path d="M22 22 L36 36 M78 22 L64 36 M78 78 L64 64 M22 78 L36 64" stroke="#222" strokeWidth="4" />
                <text x="50" y="54" textAnchor="middle" fill={color} fontSize="12" fontWeight="bold">{label}</text>
            </svg>
        );

        // --- COMPONENTE DE LÍNEA DE META ---
        const FinishLine = ({ width }) => {
            const rows = 2; 
            const size = 1.8; 
            const cols = Math.floor((width - 1) / size);
            const startZ = -(cols * size) / 2;
            const TRACK_H = 0.6;
            
            const squares = useMemo(() => {
                const els = [];
                for(let r=0; r<rows; r++) {
                    for(let c=0; c<cols; c++) {
                        const isWhite = (r + c) % 2 === 0;
                        els.push(
                            <mesh key={`${r}-${c}`} position={[r * size, 0, startZ + c * size + size/2]} rotation={[-Math.PI/2, 0, 0]}>
                                <planeGeometry args={[size, size]} />
                                <meshBasicMaterial color={isWhite ? '#ffffff' : '#111111'} />
                            </mesh>
                        );
                    }
                }
                return els;
            }, [width, size, cols, startZ, rows]);

            return (
                <group position={[2, TRACK_H + 0.02, 0]}>
                    {squares}
                    <mesh position={[-0.2, 0, 0]} rotation={[-Math.PI/2, 0, 0]}>
                        <planeGeometry args={[0.2, width]} />
                        <meshBasicMaterial color="white" />
                    </mesh>
                    <mesh position={[rows * size + 0.2, 0, 0]} rotation={[-Math.PI/2, 0, 0]}>
                        <planeGeometry args={[0.2, width]} />
                        <meshBasicMaterial color="white" />
                    </mesh>
                    <Text position={[rows * size + 3.5, 0, 0]} rotation={[-Math.PI/2, 0, -Math.PI/2]} fontSize={2.5} color="white" fontWeight="bold" letterSpacing={0.1}>
                        META
                    </Text>
                     <Text position={[-3.5, 0, 0]} rotation={[-Math.PI/2, 0, Math.PI/2]} fontSize={2.5} color="white" fontWeight="bold" letterSpacing={0.1}>
                        META
                    </Text>
                </group>
            );
        };

        const createStraightShape = (len, width) => { const s = new THREE.Shape(); s.moveTo(0,-width/2); s.lineTo(len,-width/2); s.lineTo(len,width/2); s.lineTo(0,width/2); return s; };
        const createCurveShape = (r, deg, isLeft, width) => { const s = new THREE.Shape(); const inner = r - width/2; const outer = r + width/2; const start = isLeft ? -Math.PI/2 : Math.PI/2; const rad = (deg * Math.PI)/180; const end = isLeft ? start + rad : start - rad; s.absarc(0,0, outer, start, end, !isLeft); s.lineTo(Math.cos(end)*inner, Math.sin(end)*inner); s.absarc(0,0, inner, end, start, isLeft); return s; };

        // --- MODELO COCHE BÁSICO (ESCALA 1:32 AUMENTADA) ---
        const Wheel = ({ pos, radius = 1.1, width = 1.0, spokes = false, color = "#1a1a1a", rimColor = "#e2e8f0" }) => (
             <group position={pos}>
                <mesh rotation={[Math.PI/2, 0, 0]} castShadow>
                    <cylinderGeometry args={[radius, radius, width, 32]} />
                    <meshStandardMaterial color="#1a1a1a" roughness={0.9} />
                </mesh>
                <mesh rotation={[Math.PI/2, 0, 0]} position={[0, 0, 0]}>
                    <cylinderGeometry args={[radius * 0.65, radius * 0.65, width + 0.05, 16]} />
                    <meshStandardMaterial color={rimColor} metalness={0.8} roughness={0.2} />
                </mesh>
                <mesh rotation={[Math.PI/2, 0, 0]} position={[0, 0, width/2 + 0.05]}>
                    <cylinderGeometry args={[0.15, 0.15, 0.1, 6]} />
                    <meshStandardMaterial color={color} metalness={0.5} />
                </mesh>
            </group>
        );

        // Actualizado: offsetZ para lateral, offsetX para longitudinal (si se usara)
        const StandardCar = ({ color, rotationZ = 0, offsetY = 0, offsetZ = 0 }) => (
            <group position={[0, 1.5 + offsetY, offsetZ]} rotation={[0, 0, rotationZ * Math.PI / 180]}> {/* Higher center due to larger wheels */}
                {/* Cuerpo Aumentado */}
                <mesh position={[0, 1.2, 0]} castShadow receiveShadow>
                    <boxGeometry args={[13.5, 2.4, 6.0]} /> {/* Scaled ~x3 for 1:32 feel */}
                    <meshStandardMaterial color={color} metalness={0.4} roughness={0.3} />
                </mesh>
                {/* Cabina */}
                <mesh position={[-1.5, 2.7, 0]} castShadow>
                    <boxGeometry args={[6.0, 1.5, 4.8]} /> 
                    <meshStandardMaterial color="#111" metalness={0.8} />
                </mesh>
                {/* Wheels - Adjusted positions for new scale */}
                <Wheel pos={[4.5, 0, 3.1]} radius={2.1} width={1.2} /> 
                <Wheel pos={[4.5, 0, -3.1]} radius={2.1} width={1.2} /> 
                <Wheel pos={[-4.5, 0, 3.1]} radius={2.2} width={1.5} /> 
                <Wheel pos={[-4.5, 0, -3.1]} radius={2.2} width={1.5} /> 
                
                {/* Alerón */}
                <mesh position={[-6.6, 3.0, 0]}><boxGeometry args={[1.5, 0.3, 6.0]} /><meshStandardMaterial color={color}/></mesh>
            </group>
        );

        // --- COMPONENTE DECORACIÓN PERSONALIZADA ---
        const DecorationObject = ({ objUrl, mtlUrl }) => {
            const [model, setModel] = useState(null);
            
            useEffect(() => {
                if (!objUrl) {
                    setModel(null);
                    return;
                }
                
                const loadModel = async () => {
                    try {
                        let materials = null;
                        if (mtlUrl) {
                            const mtlLoader = new MTLLoader();
                            materials = await mtlLoader.loadAsync(mtlUrl);
                            materials.preload();
                        }
                        
                        const objLoader = new OBJLoader();
                        if (materials) {
                            objLoader.setMaterials(materials);
                        }
                        const obj = await objLoader.loadAsync(objUrl);
                        
                        const box = new THREE.Box3().setFromObject(obj);
                        const size = new THREE.Vector3();
                        box.getSize(size);
                        const maxDim = Math.max(size.x, size.y, size.z);
                        
                        const TARGET_SIZE = 12.0; 
                        
                        if (maxDim > 30 || maxDim < 2) {
                            const scaleFactor = TARGET_SIZE / maxDim;
                            obj.scale.setScalar(scaleFactor);
                        }
                        
                        box.setFromObject(obj);
                        const center = new THREE.Vector3();
                        box.getCenter(center);
                        
                        obj.position.x -= center.x;
                        obj.position.z -= center.z;
                        obj.position.y -= (box.min.y); 

                        setModel(obj);
                    } catch (e) {
                        console.error("Error loading decoration model", e);
                        setModel(null);
                    }
                };
                loadModel();
            }, [objUrl, mtlUrl]);

            if (!model) return <mesh position={[0, 2.5, 0]}><boxGeometry args={[5, 5, 5]} /><meshStandardMaterial color="gray" /></mesh>;
            
            return <primitive object={model} castShadow receiveShadow />;
        };

        const DraggableDecoration = ({ data, modelInfo, isSelected, isDecoMode, onUpdate, onSelect }) => {
            const { camera, raycaster, gl } = useThree();
            const [isDragging, setIsDragging] = useState(false);
            const dragPlane = useMemo(() => new THREE.Plane(new THREE.Vector3(0, 1, 0), 0), []);
            const intersectPoint = useMemo(() => new THREE.Vector3(), []);
            
            const handlePointerDown = (e) => {
                if (!isDecoMode) return;
                e.stopPropagation();
                onSelect(data.instanceId); 
                setIsDragging(true);
                gl.domElement.style.cursor = 'grabbing';
            };

            useEffect(() => {
                const handleMove = (e) => {
                    if (!isDragging) return;
                    
                    const rect = gl.domElement.getBoundingClientRect();
                    const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                    const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
                    if (raycaster.ray.intersectPlane(dragPlane, intersectPoint)) {
                        onUpdate(data.instanceId, 'position', [intersectPoint.x, 0, intersectPoint.z]);
                    }
                };
                
                const handleUp = () => {
                    setIsDragging(false);
                    gl.domElement.style.cursor = 'auto';
                };

                if (isDragging) {
                    window.addEventListener('pointermove', handleMove);
                    window.addEventListener('pointerup', handleUp);
                }
                return () => {
                    window.removeEventListener('pointermove', handleMove);
                    window.removeEventListener('pointerup', handleUp);
                };
            }, [isDragging, camera, raycaster, gl, dragPlane, onUpdate, data.instanceId]);

            return (
                <group 
                    position={data.position} 
                    rotation={new THREE.Euler(data.rotation[0], data.rotation[1], data.rotation[2])}
                    scale={[data.scale, data.scale, data.scale]}
                    onPointerDown={handlePointerDown}
                    onPointerOver={(e) => { if(isDecoMode) { e.stopPropagation(); gl.domElement.style.cursor = 'move'; } }}
                    onPointerOut={(e) => { if(isDecoMode) gl.domElement.style.cursor = 'auto'; }}
                >
                    <DecorationObject 
                        objUrl={modelInfo?.customData?.obj} 
                        mtlUrl={modelInfo?.customData?.mtl} 
                    />
                    
                    {isSelected && isDecoMode && (
                         <mesh position={[0, 6, 0]}>
                             <boxGeometry args={[1, 14, 1]} />
                             <meshBasicMaterial color="yellow" wireframe />
                         </mesh>
                    )}
                    {isSelected && isDecoMode && (
                        <mesh position={[0, 0.1, 0]} rotation={[-Math.PI/2, 0, 0]}>
                            <ringGeometry args={[5, 6, 32]} />
                            <meshBasicMaterial color="yellow" opacity={0.6} transparent />
                        </mesh>
                    )}
                </group>
            );
        };

        // Corregido: offsetZ controla el desplazamiento lateral
        const CustomCar = ({ objUrl, mtlUrl, texUrl, color, rotationZ = 0, offsetY = 0, offsetZ = 0 }) => {
            const [model, setModel] = useState(null);
            
            useEffect(() => {
                if (!objUrl) {
                    setModel(null);
                    return;
                }
                
                const loadModel = async () => {
                    try {
                        let materials = null;
                        if (mtlUrl) {
                            const mtlLoader = new MTLLoader();
                            materials = await mtlLoader.loadAsync(mtlUrl);
                            materials.preload();
                        }
                        
                        const objLoader = new OBJLoader();
                        if (materials) {
                            objLoader.setMaterials(materials);
                        }
                        const obj = await objLoader.loadAsync(objUrl);
                        
                        // Si hay textura personalizada, cargarla y aplicarla
                        if (texUrl) {
                            const textureLoader = new THREE.TextureLoader();
                            const texture = await textureLoader.loadAsync(texUrl);
                            obj.traverse((child) => {
                                if (child.isMesh) {
                                    child.material.map = texture;
                                    child.material.needsUpdate = true;
                                }
                            });
                        }

                        // --- LÓGICA CLÁSICA SIMPLIFICADA (COMO ESTABA ANTES) ---
                        // Sin auto-rotación inteligente que causaba problemas
                        
                        const box = new THREE.Box3().setFromObject(obj);
                        const size = new THREE.Vector3();
                        box.getSize(size);
                        
                        // Escalado Estándar 1:32
                        const TARGET_LENGTH = 13.5;
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const scale = TARGET_LENGTH / maxDim;
                        obj.scale.setScalar(scale);
                        
                        // Centrado Básico
                        // Recalcular caja tras escalado
                        box.setFromObject(obj);
                        const center = new THREE.Vector3();
                        box.getCenter(center);
                        
                        // Mover al origen (0,0,0)
                        obj.position.x = -center.x;
                        obj.position.z = -center.z;
                        obj.position.y = -box.min.y; // Ruedas al suelo

                        // Aplicar color base si no hay materiales
                        if (!mtlUrl && !texUrl) {
                            obj.traverse((child) => {
                                if (child.isMesh) {
                                    child.material.color.set(color);
                                }
                            });
                        }
                        
                        // Rotación base estándar para la mayoría de OBJs de coches
                        obj.rotation.y = -Math.PI / 2; 

                        setModel(obj);
                    } catch (e) {
                        console.error("Error loading custom model", e);
                        setModel(null); // Fallback to standard
                    }
                };
                loadModel();
            }, [objUrl, mtlUrl, texUrl, color]);

            if (!model) return <StandardCar color={color} rotationZ={rotationZ} offsetY={offsetY} offsetZ={offsetZ} />; 
            
            // OffsetZ ahora controla el desplazamiento lateral (Z)
            return (
                <group position={[0, 0.5 + offsetY, offsetZ]} rotation={[0, 0, rotationZ * Math.PI / 180]}>
                    <primitive object={model} castShadow receiveShadow />
                </group>
            );
        };

        const CarModel = ({ type, color = "#dc2626", customData, rotationZ, offsetY, offsetZ }) => {
            if (type === 'CUSTOM_OBJ' && customData?.obj) {
                return <CustomCar objUrl={customData.obj} mtlUrl={customData.mtl} texUrl={customData.tex} color={color} rotationZ={rotationZ} offsetY={offsetY} offsetZ={offsetZ} />;
            }
            return <StandardCar color={color} rotationZ={rotationZ} offsetY={offsetY} offsetZ={offsetZ} />;
        };

        const createTrackSpline = (chain, selectedLane, systemPieces, systemSpecs) => {
            const points = [];
            const segmentMap = []; 
            const offset = systemSpecs.railOffset;
            let currentLaneOffset = selectedLane === 1 ? offset : -offset;
            const numCrosses = chain.filter(s => systemPieces[s.pId] && systemPieces[s.pId].isCross).length;
            const iterations = (numCrosses % 2 !== 0) ? 2 : 1;
            
            // FIX: Aumentar resolución para que la curva sea perfecta visualmente
            const SUBDIVISIONS_PER_UNIT = 2.0; 
            
            const TRACK_H = 0.6;
            let isBroken = false;

            for (let loop = 0; loop < iterations; loop++) {
                if (isBroken) break;
                for (const seg of chain) {
                    if (isBroken) break;
                    const def = systemPieces[seg.pId];
                    if (!def) continue;

                    let numSteps = 5;
                    let segLength = 0;
                    if (def.len) { numSteps = Math.max(10, Math.ceil(def.len * SUBDIVISIONS_PER_UNIT)); segLength = def.len; } 
                    else if (def.ang) { const arcLen = (def.ang * Math.PI / 180) * def.r; numSteps = Math.max(10, Math.ceil(arcLen * SUBDIVISIONS_PER_UNIT)); segLength = arcLen; }
                    
                    const isCurve = def.type === 'CURVE';
                    const radius = isCurve ? def.r : Infinity;
                    const label = def.label;
                    const dir = seg.dir; // Guardamos dirección: 1 (Izquierda), -1 (Derecha)
                    const startOffset = currentLaneOffset;
                    const endOffset = def.isCross ? -currentLaneOffset : currentLaneOffset;

                    for (let i = 0; i <= numSteps; i++) {
                        const t = i / numSteps;
                        const localPos = new THREE.Vector3();
                        if (def.type === 'STRAIGHT') {
                            if (def.isCross) {
                                const blend = (1 - Math.cos(t * Math.PI)) * 0.5;
                                const currentZ = startOffset + (endOffset - startOffset) * blend;
                                localPos.set(t * def.len, TRACK_H, currentZ);
                            } else { localPos.set(t * def.len, TRACK_H, currentLaneOffset); }
                        } else {
                            const isLeft = seg.dir === 1;
                            const Reff = isLeft ? (def.r + currentLaneOffset) : (def.r - currentLaneOffset);
                            const angleRad = t * (def.ang * Math.PI / 180);
                            if (isLeft) { const theta = -Math.PI/2 + angleRad; localPos.set(Reff * Math.cos(theta), TRACK_H, -(Reff * Math.sin(theta) + def.r)); } 
                            else { const theta = Math.PI/2 - angleRad; localPos.set(Reff * Math.cos(theta), TRACK_H, -(Reff * Math.sin(theta) - def.r)); }
                        }
                        localPos.applyMatrix4(seg.mat);
                        if (points.length > 0 && i === 0) {
                            const lastP = points[points.length - 1];
                            if (localPos.distanceTo(lastP) > 5.0) { isBroken = true; break; }
                        }
                        if (points.length === 0 || points[points.length-1].distanceTo(localPos) > 0.001) { points.push(localPos); }
                    }
                    if (!isBroken) {
                        segmentMap.push({ length: segLength, isCurve, radius, label, dir });
                        if (def.isCross) { currentLaneOffset = endOffset; }
                    }
                }
            }
            if (points.length < 2) return null;
            const closed = points.length > 2 && points[0].distanceTo(points[points.length-1]) < 20;
            const curve = new THREE.CatmullRomCurve3(points, closed, 'centripetal', 0.1); 
            const splineLength = curve.getLength();
            let accumulated = 0;
            const normalizedMap = segmentMap.map(s => { const startT = accumulated / splineLength; accumulated += s.length; const endT = accumulated / splineLength; return { ...s, startT, endT }; });
            return { curve, totalLength: splineLength, closed, points, map: normalizedMap };
        };

        const AnimatedCar = ({ chain, throttle, isPlaying, isPaused, selectedLane = 1, onLap, motor, tires, voltage, weight, onDerail, driveMode, onTelemetry, totalLaps, systemId, resetToken, carModelId, customData, modelRotation, modelRotationZ, offsetY, offsetZ }) => {
            const carRef = useRef();
            const [velocity, setVelocity] = useState(0);
            const [progress, setProgress] = useState(0);
            const [derailed, setDerailed] = useState(false);
            const [derailVector, setDerailVector] = useState(new THREE.Vector3());
            const lapTimeRef = useRef(0);
            const telemetryTick = useRef(0);
            
            const systemSpecs = TRACK_SYSTEMS[systemId];
            const systemPieces = useMemo(() => getPieces(systemSpecs), [systemId]);
            
            // Determinar tipo para renderizado
            const renderType = carModelId.startsWith('custom-') ? 'CUSTOM_OBJ' : 'STD';

            useEffect(() => { 
                setVelocity(0); 
                setProgress(0); 
                setDerailed(false); 
                lapTimeRef.current = 0; 
            }, [chain, selectedLane, systemId, resetToken]);

            const trackSpline = useMemo(() => { if (chain.length === 0) return null; return createTrackSpline(chain, selectedLane, systemPieces, systemSpecs); }, [chain, selectedLane, systemPieces, systemSpecs]);

            // FIX: Generar puntos para visualización del Spline (Debug Visual)
            const splinePoints = useMemo(() => {
                if (!trackSpline) return [];
                return trackSpline.curve.getPoints(trackSpline.totalLength * 2); // Alta resolución para dibujo
            }, [trackSpline]);

            useFrame((state, delta) => {
                if (!trackSpline || !carRef.current) return;
                
                // LÓGICA DE MOVIMIENTO FIX: Permitir movimiento si está jugando O si no está pausado (Modo Libre)
                if (!isPlaying && !derailed && !isPaused) { 
                    setVelocity(0); return; 
                }
                
                if (isPaused) {
                    return;
                }

                if (derailed) {
                    carRef.current.position.addScaledVector(derailVector, delta * 30);
                    carRef.current.rotation.y += delta * 5;
                    carRef.current.rotation.z += delta * 2; // Efecto vuelco extra
                    return;
                }

                const currentSegIdx = trackSpline.map.findIndex(s => progress >= s.startT && progress < s.endT);
                const actualIdx = currentSegIdx !== -1 ? currentSegIdx : 0;
                const currentSeg = trackSpline.map[actualIdx];

                const BASE_MAX_SPEED = 550;
                const ACCEL_FACTOR = 200;
                const BRAKE_FACTOR = 450;
                const voltageFactor = voltage / 12; 
                const motorFactor = motor.rpm / 20000;
                const carTopSpeed = BASE_MAX_SPEED * motorFactor * voltageFactor; 
                const accelRate = motor.torque * voltageFactor * ACCEL_FACTOR; 
                const brakeRate = motor.torque * BRAKE_FACTOR; 
                const realRadius = currentSeg.isCurve ? currentSeg.radius : 9999;
                const systemGrip = systemSpecs.gripFactor;
                const tireGrip = tires.grip;
                const magnetGrip = (MAGNET_FORCE / 25) * 0.6; 
                const weightPenalty = (weight - 80) * 0.005; 
                const totalGripFactor = (systemGrip + tireGrip * 0.5 + magnetGrip - weightPenalty);
                const safeCornerSpeed = Math.sqrt(realRadius * 1500 * totalGripFactor);

                let currentThrottle = throttle;
                
                if (driveMode === 'ai') {
                    const nextIdx = (actualIdx + 1) % trackSpline.map.length;
                    const nextSeg = trackSpline.map[nextIdx];
                    let speedLimit = safeCornerSpeed;

                    if (nextSeg.isCurve) {
                        const nextRadius = nextSeg.radius;
                        const nextCornerLimit = Math.sqrt(nextRadius * 1500 * totalGripFactor);
                        
                        if (velocity > nextCornerLimit * 0.95) {
                            const segmentProgress = (progress - currentSeg.startT) / (currentSeg.endT - currentSeg.startT);
                            if (segmentProgress > 0.70) {
                                speedLimit = nextCornerLimit * 0.95;
                            }
                        }
                    }

                    if (velocity > speedLimit) currentThrottle = 0; 
                    else currentThrottle = 0.9 + (motorFactor * 0.05); 
                }

                const targetSpeed = currentThrottle * carTopSpeed;
                let newVelocity = velocity;

                if (targetSpeed > velocity) {
                    newVelocity += accelRate * delta;
                    if (newVelocity > targetSpeed) newVelocity = targetSpeed;
                } else {
                    newVelocity -= brakeRate * delta;
                    if (newVelocity < targetSpeed) newVelocity = targetSpeed;
                }

                const realSpeedKmH = newVelocity * 0.036;
                const limitRealSpeedKmH = safeCornerSpeed * 0.036;

                telemetryTick.current += 1;
                if (onTelemetry && telemetryTick.current > 10) {
                    telemetryTick.current = 0;
                    onTelemetry({
                        speed: realSpeedKmH, 
                        limit: limitRealSpeedKmH,
                        section: currentSeg.label,
                        throttle: currentThrottle,
                        gForce: (newVelocity * newVelocity) / (realRadius * 980),
                        gripLimit: (newVelocity / safeCornerSpeed) * 100 
                    });
                }
                
                const DERAIL_THRESHOLD = safeCornerSpeed * 1.15;

                if (currentSeg.isCurve && newVelocity > DERAIL_THRESHOLD) {
                    setDerailed(true);
                    const tangent = trackSpline.curve.getTangentAt(progress).normalize();
                    const up = new THREE.Vector3(0, 1, 0);
                    const normal = new THREE.Vector3().crossVectors(tangent, up).normalize();
                    const exitVec = tangent.clone().multiplyScalar(0.7).add(normal.multiplyScalar(0.5)); 
                    setDerailVector(exitVec);
                    if(onDerail) onDerail();
                    setTimeout(() => { setDerailed(false); setVelocity(0); }, 2000);
                    return;
                }

                setVelocity(newVelocity);

                const VISUAL_SCALE = 1.0; 
                const moveDist = delta * newVelocity * VISUAL_SCALE;
                const progressDelta = moveDist / trackSpline.totalLength;
                
                lapTimeRef.current += delta;
                let nextProgress = progress + progressDelta;

                if (nextProgress >= 1) {
                    if (trackSpline.closed) {
                        nextProgress = nextProgress % 1;
                        if (onLap) onLap(lapTimeRef.current);
                        lapTimeRef.current = 0;
                    } else {
                         nextProgress = 0;
                         setVelocity(0); 
                         if (onLap) onLap(lapTimeRef.current);
                         lapTimeRef.current = 0;
                    }
                }
                setProgress(nextProgress);

                // --- FÍSICAS AVANZADAS DE SLOT ---
                // REESCRITO: Pivotaje desde la Guía (Morro)
                
                // 1. POSICIÓN (Fijar la GUÍA al raíl)
                const point = trackSpline.curve.getPointAt(nextProgress);
                carRef.current.position.copy(point);
                
                // 2. ROTACIÓN BASE (Tangente exacta)
                const tangent = trackSpline.curve.getTangentAt(nextProgress).normalize();
                const baseQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1, 0, 0), tangent);
                
                // 3. EFECTO DERRAPE (Drift)
                let driftAngle = 0;
                
                if (currentSeg.isCurve) {
                    const speedRatio = Math.min(1.2, newVelocity / safeCornerSpeed);
                    if (speedRatio > 0.3) {
                        const MAX_DRIFT = 35 * (Math.PI / 180);
                        const intensity = Math.pow(speedRatio, 2.5);
                        
                        // FIX: El coche pivota en el morro. 
                        // Para que la cola se vaya hacia afuera, necesitamos rotar el coche HACIA ADENTRO de la curva.
                        // Si la curva es IZQ (dir=1), rotamos +Y (morro mira más a izquierda, culo sale a derecha).
                        // Si la curva es DER (dir=-1), rotamos -Y (morro mira más a derecha, culo sale a izquierda).
                        const direction = currentSeg.dir || 1; 
                        driftAngle = direction * intensity * MAX_DRIFT * 0.8;
                    }
                }
                
                // Aplicar rotación base
                carRef.current.quaternion.copy(baseQuaternion);
                
                // Añadir derrape a la rotación Y local (Pivotando sobre el morro ahora)
                carRef.current.rotateY(driftAngle);

            });

            return (
                <group>
                    {/* DIBUJAR SPLINE (El raíl virtual) */}
                    {trackSpline && (
                        <Line 
                            points={splinePoints} 
                            color={selectedLane === 1 ? "cyan" : "orange"} 
                            lineWidth={1.5} 
                            position={[0, 0.7, 0]} // Un poco elevado para que se vea sobre la pista
                            opacity={0.6}
                            transparent
                        />
                    )}

                    <group ref={carRef}>
                        {/* FIX PIVOTAJE: Desplazamos la geometría del coche hacia atrás.
                            El 'group ref={carRef}' está en la posición del raíl.
                            Al mover el hijo hacia atrás (x = -5.0), el punto (0,0,0) del padre
                            coincide con el MORRO (Guía) del coche, no con el centro.
                        */}
                        <group position={[-5.0, 0, 0]}>
                            <group rotation={[0, modelRotation * Math.PI / 180, 0]}>
                                <CarModel 
                                    type={renderType} 
                                    color={selectedLane === 1 ? "#ef4444" : "#3b82f6"} 
                                    customData={customData} 
                                    rotationZ={modelRotationZ} 
                                    offsetY={offsetY} 
                                    offsetZ={offsetZ} 
                                />
                            </group>
                        </group>
                        
                        {derailed && (<Text position={[0, 4, 0]} fontSize={2} color="yellow" rotation={[0, Math.PI/2, 0]}>!</Text>)}
                        {driveMode === 'ai' && (<Text position={[0, 5, 0]} fontSize={1.5} color="#3b82f6" rotation={[0, Math.PI/2, 0]}>AI</Text>)}
                    </group>
                </group>
            );
        };
        
        class ErrorBoundary extends React.Component {
            constructor(props) { super(props); this.state = { hasError: false }; }
            static getDerivedStateFromError(error) { return { hasError: true }; }
            componentDidCatch(error, errorInfo) { console.error("Error cargando modelo:", error); }
            render() { if (this.state.hasError) { return this.props.fallback; } return this.props.children; }
        }

        const DraggableBoard = React.forwardRef(({ width, length, enabled, onBoardClick, isPlacingTree, isDecoMode }, ref) => {
            const { camera, raycaster, gl } = useThree();
            const [isDragging, setIsDragging] = useState(false);
            const dragPlane = useMemo(() => new THREE.Plane(new THREE.Vector3(0, 1, 0), 0), []);
            const intersectPoint = useMemo(() => new THREE.Vector3(), []);
            const offset = useRef(new THREE.Vector3());
            const boardGeometry = useMemo(() => new THREE.BoxGeometry(width, length, 1.2), [width, length]);

            const handlePointerDown = (e) => {
                if (isDecoMode) return; 

                if (!enabled || !ref.current || isPlacingTree) return; 
                e.stopPropagation();
                offset.current.subVectors(ref.current.position, e.point);
                setIsDragging(true);
                gl.domElement.style.cursor = 'grabbing';
            };
            
            const handleClick = (e) => {
                if ((isPlacingTree || isDecoMode) && onBoardClick) {
                    e.stopPropagation();
                    onBoardClick(e.point);
                }
            };

            useEffect(() => {
                const handleMove = (e) => {
                    if (!isDragging || !ref.current) return;
                    const rect = gl.domElement.getBoundingClientRect();
                    const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                    const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                    raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
                    if (raycaster.ray.intersectPlane(dragPlane, intersectPoint)) {
                        ref.current.position.x = intersectPoint.x + offset.current.x;
                        ref.current.position.z = intersectPoint.z + offset.current.z;
                    }
                };
                const handleUp = () => { setIsDragging(false); if (gl.domElement) gl.domElement.style.cursor = 'auto'; };
                if (isDragging) { window.addEventListener('pointermove', handleMove); window.addEventListener('pointerup', handleUp); }
                return () => { window.removeEventListener('pointermove', handleMove); window.removeEventListener('pointerup', handleUp); };
            }, [isDragging, camera, raycaster, gl, dragPlane]);

            if (!width || !length) return null;
            
            const cursorStyle = (isPlacingTree || isDecoMode) ? 'crosshair' : (enabled ? 'grab' : 'auto');

            return (
                <mesh 
                    ref={ref} 
                    rotation={[-Math.PI / 2, 0, 0]} 
                    position={[0, -0.6, 0]} 
                    receiveShadow 
                    onPointerDown={handlePointerDown} 
                    onClick={handleClick}
                    onPointerOver={() => { if(gl.domElement) gl.domElement.style.cursor = cursorStyle; }}
                    onPointerOut={() => { if(gl.domElement) gl.domElement.style.cursor = 'auto'; }}
                    geometry={boardGeometry}
                >
                    <meshStandardMaterial color={enabled ? "#16a34a" : "#15803d"} roughness={1} />
                    <lineSegments position={[0,0,0.61]} rotation={[0,0,0]}>
                        <edgesGeometry args={[boardGeometry]} />
                        <lineBasicMaterial color={enabled ? "#ffff00" : "#ffffff"} linewidth={2} opacity={0.3} transparent />
                    </lineSegments>
                    <gridHelper args={[Math.max(width, length), Math.max(width, length)/10]} rotation={[Math.PI/2, 0, 0]} position={[0,0,0.61]} material-opacity={0.1} material-transparent />
                </mesh>
            );
        });

        const StartPieceHandler = ({ children, position, onPosChange, isSelected, enabled, dragEnabled, id }) => {
            const { camera, raycaster, gl } = useThree();
            const [isDragging, setIsDragging] = useState(false);
            const plane = useMemo(() => new THREE.Plane(new THREE.Vector3(0, 1, 0), 0), []);
            const intersectPoint = useMemo(() => new THREE.Vector3(), []);
            const [hovered, setHovered] = useState(false);
            
            const handlePointerDown = (e) => {
                if (!dragEnabled) return; 
                e.stopPropagation();
                setIsDragging(true);
                if (gl.domElement) gl.domElement.style.cursor = 'grabbing';
            };

            useEffect(() => {
                const handleMove = (e) => {
                    if (!isDragging || !dragEnabled) return;
                    const rect = gl.domElement.getBoundingClientRect();
                    const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                    const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                    raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
                    if (raycaster.ray.intersectPlane(plane, intersectPoint)) {
                        const snapX = Math.round(intersectPoint.x);
                        const snapZ = Math.round(intersectPoint.z);
                        onPosChange(id, new THREE.Vector3(snapX, 0, snapZ));
                    }
                };
                const handleUp = () => { setIsDragging(false); if (gl.domElement) gl.domElement.style.cursor = 'auto'; };
                if (isDragging) { window.addEventListener('pointermove', handleMove); window.addEventListener('pointerup', handleUp); }
                return () => { window.removeEventListener('pointermove', handleMove); window.removeEventListener('pointerup', handleUp); };
            }, [isDragging, dragEnabled, camera, raycaster, gl, plane, onPosChange, id]);

            return (
                <group 
                    position={position} 
                >
                    {children}
                    
                    {dragEnabled && (
                        <group 
                            position={[20, 15, 0]} 
                            onPointerDown={handlePointerDown}
                            onPointerOver={() => { setHovered(true); gl.domElement.style.cursor = 'move'; }}
                            onPointerOut={() => { setHovered(false); gl.domElement.style.cursor = 'auto'; }}
                        >
                            <mesh>
                                <sphereGeometry args={[8, 32, 32]} />
                                <meshStandardMaterial color={hovered || isDragging ? "#facc15" : "#eab308"} transparent opacity={0.8} />
                            </mesh>
                            <group scale={[2.5, 2.5, 2.5]} position={[0,0,0]}>
                                {/* Arrows */}
                                <mesh position={[3, 0, 0]} rotation={[0, 0, -Math.PI/2]}>
                                    <coneGeometry args={[0.8, 2, 8]} />
                                    <meshBasicMaterial color="white" />
                                </mesh>
                                <mesh position={[-3, 0, 0]} rotation={[0, 0, Math.PI/2]}>
                                    <coneGeometry args={[0.8, 2, 8]} />
                                    <meshBasicMaterial color="white" />
                                </mesh>
                                <mesh position={[0, 0, 3]} rotation={[Math.PI/2, 0, 0]}>
                                    <coneGeometry args={[0.8, 2, 8]} />
                                    <meshBasicMaterial color="white" />
                                </mesh>
                                <mesh position={[0, 0, -3]} rotation={[-Math.PI/2, 0, 0]}>
                                    <coneGeometry args={[0.8, 2, 8]} />
                                    <meshBasicMaterial color="white" />
                                </mesh>
                            </group>
                            <Text position={[0, 12, 0]} fontSize={6} color="yellow" anchorX="center" anchorY="middle" rotation={[-Math.PI/2, 0, 0]} fontWeight="bold" outlineWidth={0.2} outlineColor="black">
                                ARRASTRAR
                            </Text>
                        </group>
                    )}

                    {isSelected && enabled && !dragEnabled && (
                        <group position={[20, 5, 0]}>
                            <Text fontSize={4} color="white" anchorX="center" anchorY="middle" rotation={[-Math.PI/2, 0, 0]}>SALIDA</Text>
                            <mesh position={[0, -2, 0]} rotation={[-Math.PI/2, 0, 0]}><circleGeometry args={[8, 32]} /><meshBasicMaterial color="red" opacity={0.3} transparent /></mesh>
                        </group>
                    )}
                </group>
            );
        };

        const TrackMesh = ({ def, isLeft, isSelected, onClick, systemSpecs }) => {
            const { width, railOffset, railGap, color } = systemSpecs;
            const TRACK_H = 0.6;

            const geom = useMemo(() => {
                if (!def) return null;
                if (def.type === 'STRAIGHT') { const g = new THREE.ExtrudeGeometry(createStraightShape(def.len, width), {depth: TRACK_H, bevelEnabled:false}); g.rotateX(-Math.PI/2); return g; } 
                else { const g = new THREE.ExtrudeGeometry(createCurveShape(def.r, def.ang, isLeft, width), {depth: TRACK_H, bevelEnabled:false, curveSegments:64}); const yOff = isLeft ? def.r : -def.r; g.translate(0, yOff, 0); g.rotateX(-Math.PI/2); return g; }
            }, [def, isLeft, width]);
            
            const fenceGeom = useMemo(() => {
                if (!def || def.type !== 'CURVE') return null;
                
                const fenceHeight = 2.5; 
                const fenceThickness = 0.3;
                const outerRadius = def.r + width/2 + 0.5; 
                
                const shape = new THREE.Shape();
                const start = isLeft ? -Math.PI/2 : Math.PI/2;
                const rad = (def.ang * Math.PI)/180;
                const end = isLeft ? start + rad : start - rad;
                
                shape.absarc(0, 0, outerRadius + fenceThickness, start, end, !isLeft);
                shape.absarc(0, 0, outerRadius, end, start, isLeft);
                
                const g = new THREE.ExtrudeGeometry(shape, { depth: fenceHeight, bevelEnabled: false, curveSegments: 32 });
                const yOff = isLeft ? def.r : -def.r; 
                g.translate(0, yOff, 0); 
                g.rotateX(-Math.PI/2);
                return g;
            }, [def, isLeft, width]);

            const trackMat = useMemo(() => new THREE.MeshStandardMaterial({ color: isSelected ? '#ef4444' : systemSpecs.color, roughness: 0.7, metalness: 0.1 }), [isSelected, systemSpecs.color]);
            const railMat = useMemo(() => new THREE.MeshStandardMaterial({ color: '#c0c0c0', metalness: 0.8, roughness: 0.3 }), []);
            
            const fenceMat = useMemo(() => {
                const canvas = document.createElement('canvas');
                // Resolución baja es suficiente para color sólido
                canvas.width = 128; 
                canvas.height = 128; 
                const ctx = canvas.getContext('2d');
                
                // Color Gris Plástico Genérico (sin letras)
                ctx.fillStyle = '#64748b'; // Gris azulado medio (Slate 500)
                ctx.fillRect(0,0,128,128);
                
                // Borde superior un poco más claro para dar relieve 3D
                ctx.fillStyle = '#94a3b8'; 
                ctx.fillRect(0, 0, 128, 8); 
                
                // Borde inferior un poco más oscuro
                ctx.fillStyle = '#475569';
                ctx.fillRect(0, 120, 128, 8);
                
                // SIN TEXTO - LIMPIO
                
                const tex = new THREE.CanvasTexture(canvas);
                
                return new THREE.MeshStandardMaterial({ map: tex, roughness: 0.6, metalness: 0.1 });
            }, [def, systemSpecs]);

            const rails = useMemo(() => {
                if (!def) return null;
                if(def.type === 'STRAIGHT') {
                    if (def.isCross) {
                         const l_start = -railOffset; const l_end = railOffset; const H_RAIL = 0.05; const TANGENT_DIST = def.len * 0.35; 
                         const makeSCurve = (zStart, zEnd) => new THREE.CubicBezierCurve3(new THREE.Vector3(0, H_RAIL, zStart), new THREE.Vector3(TANGENT_DIST, H_RAIL, zStart), new THREE.Vector3(def.len - TANGENT_DIST, H_RAIL, zEnd), new THREE.Vector3(def.len, H_RAIL, zEnd));
                         const c1_L = makeSCurve(l_start - railGap, l_end - railGap); const c1_R = makeSCurve(l_start + railGap, l_end + railGap); const c2_L = makeSCurve(l_end - railGap, l_start - railGap); const c2_R = makeSCurve(l_end + railGap, l_start + railGap);
                         return (<group position={[0, TRACK_H, 0]}><mesh geometry={new THREE.TubeGeometry(c1_L, 32, 0.08, 8, false)} material={railMat} /><mesh geometry={new THREE.TubeGeometry(c1_R, 32, 0.08, 8, false)} material={railMat} /><mesh geometry={new THREE.TubeGeometry(c2_L, 32, 0.08, 8, false)} material={railMat} /><mesh geometry={new THREE.TubeGeometry(c2_R, 32, 0.08, 8, false)} material={railMat} /></group>);
                    } else { return (<group position={[0, TRACK_H+0.05, 0]}>{[-railOffset - railGap, -railOffset + railGap, railOffset - railGap, railOffset + railGap].map((off, i) => (<mesh key={i} position={[def.len/2, 0, off]} rotation={[-Math.PI/2,0,0]}><planeGeometry args={[def.len, 0.15]} /><primitive object={railMat} attach="material"/></mesh>))}</group>); }
                } else {
                    const mkArc = (rOff) => { const s = new THREE.Shape(); const st = isLeft ? -Math.PI/2 : Math.PI/2; const rad = (def.ang * Math.PI)/180; const en = isLeft ? st + rad : st - rad; s.absarc(0,0, rOff + 0.075, st, en, !isLeft); s.absarc(0,0, rOff - 0.075, en, st, isLeft); const g = new THREE.ExtrudeGeometry(s, {depth:0.02, bevelEnabled:false, curveSegments:64}); g.translate(0, isLeft ? def.r : -def.r, 0); g.rotateX(-Math.PI/2); return g; };
                    return (<group position={[0, TRACK_H, 0]}>{ [def.r - railOffset - railGap, def.r - railOffset + railGap, def.r + railOffset - railGap, def.r + railOffset + railGap].map((off, i) => <mesh key={i} geometry={mkArc(off)} material={railMat} />)}</group>);
                }
            }, [def, isLeft, railMat, railOffset, railGap]);

            return (
                <group onClick={onClick}>
                    <mesh geometry={geom} receiveShadow castShadow material={trackMat}>
                        {isSelected && <lineSegments><edgesGeometry args={[geom]} /><lineBasicMaterial color="#ffffff" /></lineSegments>}
                        {def.isPower && (<group position={[def.len/2, 0, 0]}><mesh position={[0, TRACK_H+0.5, -(width/2 + 2)]}><boxGeometry args={[10, 1, 4]} /><meshStandardMaterial color="#dc2626" /></mesh><mesh position={[0, TRACK_H+1.1, -(width/2 + 2)]} rotation={[-Math.PI/2,0,0]}><planeGeometry args={[8, 3]} /><meshBasicMaterial color="#ef4444" /></mesh></group>)}
                        {def.isHalf && (<mesh position={[0, TRACK_H+0.01, 0]} rotation={[-Math.PI/2,0,0]}><ringGeometry args={[def.r-0.5, def.r+0.5, 32, 1, isLeft?-Math.PI/2:Math.PI/2, (def.ang*Math.PI)/180 * (isLeft?1:-1)]} /><meshBasicMaterial color={def.col} opacity={0.5} transparent /></mesh>)}
                    </mesh>
                    {rails}
                    <mesh position={[0, TRACK_H/2, 0]}><boxGeometry args={[0.2, TRACK_H, width-0.5]} /><meshBasicMaterial color="#000" /></mesh>
                    {fenceGeom && (
                        <mesh geometry={fenceGeom} material={fenceMat} position={[0, 0, 0]} castShadow receiveShadow />
                    )}
                </group>
            );
        };

        const SceneManager = ({ appMode, viewMode, onCaptureReady, boardRef, boardSize, setViewMode }) => {
            const { camera, controls, gl, scene } = useThree();
            useEffect(() => {
                if (viewMode === 'editor') {
                    if (appMode === 'builder') { camera.position.set(0, 500, 0); camera.lookAt(0,0,0); if(controls) { controls.target.set(0,0,0); controls.update(); } } 
                    else if (appMode === 'racer') { camera.position.set(0, 200, 300); if(controls) { controls.target.set(0,0,0); controls.update(); } }
                }
            }, [appMode, viewMode, camera, controls]);

            useEffect(() => {
                if (viewMode === 'capturing') {
                    const oldBg = scene.background; scene.background = new THREE.Color('#ffffff');
                    const padding = 1.1; let targetX = 0; let targetZ = 0; let dimX = 200; let dimZ = 200;
                    if (boardRef && boardRef.current) { targetX = boardRef.current.position.x; targetZ = boardRef.current.position.z; dimX = boardSize.width; dimZ = boardSize.length; }
                    const vFOV = THREE.MathUtils.degToRad(camera.fov); const aspect = gl.domElement.clientWidth / gl.domElement.clientHeight;
                    const finalHeight = Math.max((dimZ / 2) / Math.tan(vFOV / 2), (dimX / 2) / (Math.tan(vFOV / 2) * aspect)) * padding;
                    camera.position.set(targetX, finalHeight, targetZ); camera.lookAt(targetX, 0, targetZ); camera.rotation.set(-Math.PI/2, 0, 0); camera.updateProjectionMatrix();
                    if (controls) controls.enabled = false; 
                    setTimeout(() => { gl.render(scene, camera); const dataUrl = gl.domElement.toDataURL('image/jpeg', 1.0); onCaptureReady(dataUrl); scene.background = oldBg; if (controls) controls.enabled = true; }, 300);
                } else if (viewMode === 'reset_view') { camera.position.set(0, 400, 200); camera.lookAt(0,0,0); if (controls) { controls.target.set(0, 0, 0); controls.update(); } setViewMode('editor'); }
            }, [viewMode, camera, controls, gl, scene, onCaptureReady, boardRef, boardSize, setViewMode]);
            return null;
        };

        const CameraEventsListener = ({ enabled }) => {
            const { camera, controls } = useThree();
            useEffect(() => {
                if (!enabled) return;
                const handleCmd = (e) => {
                    if (!controls) return;
                    const { type, val, x, y } = e.detail;
                    if (type === 'zoom') { camera.position.y = Math.max(50, camera.position.y + val); } 
                    else if (type === 'rotate') { const currentAzimuth = controls.getAzimuthalAngle(); controls.setAzimuthalAngle(currentAzimuth + (Math.PI/2 * val)); } 
                    else if (type === 'pan') { const speed = 50; const vecRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion).setY(0).normalize(); const vecUp = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion).setY(0).normalize(); camera.position.addScaledVector(vecRight, x * speed).addScaledVector(vecUp, y * speed); controls.target.addScaledVector(vecRight, x * speed).addScaledVector(vecUp, y * speed); }
                    controls.update();
                };
                window.addEventListener('ninco-cmd', handleCmd); return () => window.removeEventListener('ninco-cmd', handleCmd);
            }, [enabled, camera, controls]);
            return null;
        };

        const TouchControlsOverlay = ({ enabled }) => {
            if (!enabled) return null;
            const emit = (type, payload) => { window.dispatchEvent(new CustomEvent('ninco-cmd', { detail: { type, ...payload } })); };
            return (
                <div className="touch-controls">
                    <div className="flex gap-2 mb-2">
                         <button className="touch-btn" onClick={() => emit('zoom', { val: -50 })}><ZoomIn size={24} /></button>
                         <button className="touch-btn" onClick={() => emit('zoom', { val: 50 })}><ZoomOut size={24} /></button>
                    </div>
                    <div className="flex gap-2 mb-2">
                        <button className="touch-btn" onClick={() => emit('rotate', { val: -1 })}><RotateCcw size={24} /></button>
                        <button className="touch-btn" onClick={() => emit('rotate', { val: 1 })}><RotateCw size={24} /></button>
                    </div>
                    <div className="flex flex-col items-center gap-1 bg-slate-900/90 p-2 rounded-xl border border-slate-600 shadow-xl">
                        <button className="touch-pad-btn" onClick={() => emit('pan', { x: 0, y: 1 })}><ArrowUp size={24}/></button>
                        <div className="flex gap-1"><button className="touch-pad-btn" onClick={() => emit('pan', { x: -1, y: 0 })}><ArrowLeft size={24}/></button><div className="w-[45px] h-[45px] flex items-center justify-center text-slate-500"><Move size={20}/></div><button className="touch-pad-btn" onClick={() => emit('pan', { x: 1, y: 0 })}><ArrowRight size={24}/></button></div>
                        <button className="touch-pad-btn" onClick={() => emit('pan', { x: 0, y: -1 })}><ArrowDown size={24}/></button>
                    </div>
                </div>
            );
        };

        const PreviewModal = ({ data, onClose }) => {
            return (
                <div className="absolute inset-0 z-[200] flex items-center justify-center bg-black/80 backdrop-blur-sm animate-fade-in p-4">
                     <div className="bg-slate-900 border border-slate-700 rounded-xl shadow-2xl w-full max-w-lg h-[60vh] flex flex-col relative overflow-hidden">
                        <div className="absolute top-0 left-0 w-full p-3 flex justify-between items-center z-10 bg-gradient-to-b from-black/80 to-transparent pointer-events-none">
                            <h3 className="text-white font-bold uppercase tracking-wider drop-shadow-md px-2">{data.name}</h3>
                            <button onClick={onClose} className="p-1 rounded-full bg-black/50 hover:bg-red-600 text-white transition pointer-events-auto"><X size={20}/></button>
                        </div>
                        
                        <Canvas shadows dpr={[1, 2]} camera={{ position: [0, 0, 10], fov: 50 }}>
                             <color attach="background" args={['#0f172a']} />
                             <ambientLight intensity={1.5} />
                             <directionalLight position={[5, 10, 5]} intensity={2} />
                             <pointLight position={[-10, -10, -10]} intensity={0.5} color="white" />
                             
                             <Suspense fallback={null}>
                                <Stage environment={null} intensity={1} adjustCamera={1.2}>
                                    {data.type === 'CAR' ? (
                                        <CarModel type={data.subType || 'CUSTOM_OBJ'} color={data.color} customData={{obj: data.obj, mtl: data.mtl, tex: data.tex}} rotationZ={0} />
                                    ) : (
                                        <DecorationObject objUrl={data.obj} mtlUrl={data.mtl} isSelected={false} />
                                    )}
                                </Stage>
                             </Suspense>
                             <OrbitControls makeDefault autoRotate autoRotateSpeed={2} />
                        </Canvas>
                        
                        <div className="p-3 bg-slate-800 border-t border-slate-700 text-center">
                            <p className="text-xs text-slate-400 font-mono">Vista Previa 3D - Arrastra para rotar</p>
                        </div>
                     </div>
                </div>
            );
        };

        function App() {
            const [appMode, setAppMode] = useState('builder'); 
            const [currentSystem, setCurrentSystem] = useState('ninco'); 
            const [boardSize, setBoardSize] = useState({ width: 0, length: 0 }); 
            const [inputSize, setInputSize] = useState({ width: '244', length: '122' });
            const [showBoardConfig, setShowBoardConfig] = useState(true);
            const [moveMode, setMoveMode] = useState('none'); 
            const boardRef = useRef();
            const fileInputRef = useRef();
            
            const objInputRef = useRef();
            const mtlInputRef = useRef();
            const imgInputRef = useRef(); 
            
            const decoObjRef = useRef();
            const decoMtlRef = useRef();
            const [decoMode, setDecoMode] = useState(false);
            const [customDecos, setCustomDecos] = useState([]);
            const [placedDecos, setPlacedDecos] = useState([]);
            const [activeDecoId, setActiveDecoId] = useState(null);
            const [selectedDecoInstance, setSelectedDecoInstance] = useState(null);
            
            const [showSetup, setShowSetup] = useState(false);
            const [isCrashed, setIsCrashed] = useState(false);
            
            const [confirmModal, setConfirmModal] = useState(null);
            const [previewData, setPreviewData] = useState(null);
            
            const initAudio = async () => { if (window.Tone) { await Tone.start(); Tone.Transport.start(); } };
            const playToneBeep = (note = "A4", duration = "0.1") => { if (!window.Tone) return; const synth = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(); synth.volume.value = -5; synth.triggerAttackRelease(note, duration); };
            const playToneStart = () => { if (!window.Tone) return; const poly = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.5, release: 1 } }).toDestination(); poly.volume.value = -2; poly.triggerAttackRelease(["C4", "E4", "G4", "C5"], 0.6); };
            const playCrashSound = () => { if (!window.Tone) return; const noise = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.3, sustain: 0 } }).toDestination(); noise.triggerAttackRelease("0.3"); };
            const speak = (text, interrupt = false) => { if (!window.speechSynthesis) return; if (interrupt) window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(text); u.lang = 'es-ES'; u.rate = 1.1; window.speechSynthesis.speak(u); };

            const [carEnabled, setCarEnabled] = useState(true); 
            const [carThrottle, setCarThrottle] = useState(0); 
            const [selectedLane, setSelectedLane] = useState(1); 
            const [selectedVoltage, setSelectedVoltage] = useState(12);
            const [carWeight, setCarWeight] = useState(85); 
            
            const [selectedCarModelId, setSelectedCarModelId] = useState('gt3_red');
            const [customCars, setCustomCars] = useState([]);

            const [motors, setMotors] = useState(INITIAL_MOTORS);
            const [tires, setTires] = useState(INITIAL_TIRES);
            const [selectedMotor, setSelectedMotor] = useState(INITIAL_MOTORS[1]); 
            const [selectedTire, setSelectedTire] = useState(INITIAL_TIRES[1]);

            // FIX: DriveMode por defecto en MANUAL para que el coche no se escape solo al inicio
            const [driveMode, setDriveMode] = useState('manual'); 
            const [targetLaps, setTargetLaps] = useState(10);
            
            const [raceState, setRaceState] = useState('idle'); 
            const [lightStep, setLightStep] = useState(0);
            const [raceData, setRaceData] = useState({ currentLap: 0, lastLapTime: 0, bestLap: 0, totalTime: 0, avgLap: 0 });
            const raceStartTime = useRef(0);
            const [resetToken, setResetToken] = useState(0); 
            
            const [telemetry, setTelemetry] = useState({ speed: 0, limit: 100, section: 'STD', throttle: 0, gForce: 0, gripLimit: 0 });

            const [segments, setSegments] = useState([ { id: 1, pId: 'STD', dir: 1, type: 'START', pos: new THREE.Vector3(), rot: new THREE.Euler() } ]);
            const [selId, setSelId] = useState(1);
            const [nextDir, setNextDir] = useState(1);
            const [viewMode, setViewMode] = useState('editor'); 
            const [snapshotUrl, setSnapshotUrl] = useState(null);
            
            // --- CARGA DE DATOS ---
            useEffect(() => {
                const loadPersistentData = async () => {
                    try {
                        const savedCars = await get('ninco-custom-cars');
                        if (savedCars && Array.isArray(savedCars)) {
                            const hydratedCars = savedCars.map(c => ({ 
                                ...c, 
                                customData: { 
                                    obj: c.storage?.objBlob ? URL.createObjectURL(c.storage.objBlob) : null, 
                                    mtl: c.storage?.mtlBlob ? URL.createObjectURL(c.storage.mtlBlob) : null,
                                    tex: c.storage?.texBlob ? URL.createObjectURL(c.storage.texBlob) : null 
                                } 
                            }));
                            setCustomCars(hydratedCars);
                            if (hydratedCars.length > 0) setSelectedCarModelId(hydratedCars[hydratedCars.length - 1].id);
                        }
                        const savedDecos = await get('ninco-custom-decos');
                        if (savedDecos && Array.isArray(savedDecos)) {
                            const hydratedDecos = savedDecos.map(d => ({ ...d, customData: { obj: d.storage?.objBlob ? URL.createObjectURL(d.storage.objBlob) : null, mtl: d.storage?.mtlBlob ? URL.createObjectURL(d.storage.mtlBlob) : null } }));
                            setCustomDecos(hydratedDecos);
                            if (hydratedDecos.length > 0) setActiveDecoId(hydratedDecos[0].id);
                        }
                        const savedMotors = await get('ninco-motors'); if (savedMotors) setMotors(savedMotors);
                        const savedTires = await get('ninco-tires'); if (savedTires) setTires(savedTires);
                    } catch (err) { console.error("Error cargando datos persistentes:", err); }
                };
                loadPersistentData();
            }, []);
            
            const systemSpecs = TRACK_SYSTEMS[currentSystem];
            const piecesDef = useMemo(() => getPieces(systemSpecs), [currentSystem]);
            const { chain, pieceMaps } = useMemo(() => {
                const results = []; const maps = {}; let matrix = new THREE.Matrix4(); 
                segments.forEach(seg => {
                    const def = piecesDef[seg.pId]; if (!def) return; 
                    if (seg.type === 'START') { matrix = new THREE.Matrix4().makeRotationFromEuler(seg.rot); matrix.setPosition(seg.pos); }
                    const isLeft = seg.dir === 1; const currentPos = new THREE.Vector3(); const currentRot = new THREE.Quaternion(); const currentScale = new THREE.Vector3(); matrix.decompose(currentPos, currentRot, currentScale);
                    const segmentData = { ...seg, pos: currentPos, rot: new THREE.Euler().setFromQuaternion(currentRot), mat: matrix.clone() }; results.push(segmentData); maps[seg.id] = segmentData;
                    const transform = new THREE.Matrix4(); if (def.type === 'STRAIGHT') { transform.makeTranslation(def.len, 0, 0); } else { const rad = (def.ang * Math.PI) / 180; const dx = def.r * Math.sin(rad); const dz = def.r * (1 - Math.cos(rad)) * (isLeft ? -1 : 1); const translation = new THREE.Matrix4().makeTranslation(dx, 0, dz); const rotation = new THREE.Matrix4().makeRotationY(isLeft ? rad : -rad); transform.multiply(translation).multiply(rotation); } matrix.multiply(transform);
                }); return { chain: results, pieceMaps: maps };
            }, [segments, piecesDef]);
            
            const stats = useMemo(() => {
                let totalLen = 0; const counts = {}; chain.forEach(seg => { const def = piecesDef[seg.pId]; if(!def) return; counts[def.label] = (counts[def.label] || 0) + 1; if (def.type === 'STRAIGHT') { totalLen += (def.len * 2); } else { const rad = (def.ang * Math.PI) / 180; totalLen += (rad * (def.r - systemSpecs.railOffset)) + (rad * (def.r + systemSpecs.railOffset)); } });
                const inventoryList = Object.entries(counts); return { totalLen: (totalLen / 100).toFixed(2), inventory: inventoryList, totalPieces: inventoryList.reduce((acc, [_, c]) => acc + c, 0) };
            }, [chain, piecesDef, systemSpecs]);
            
            const pointerMatrix = useMemo(() => { if (chain.length === 0) return new THREE.Matrix4(); const last = chain[chain.length-1]; const def = piecesDef[last.pId]; const m = last.mat.clone(); const isLeft = last.dir === 1; const transform = new THREE.Matrix4(); if (def.type === 'STRAIGHT') { transform.makeTranslation(def.len, 0, 0); } else { const rad = (def.ang * Math.PI) / 180; const dx = def.r * Math.sin(rad); const dz = def.r * (1 - Math.cos(rad)) * (isLeft ? -1 : 1); const translation = new THREE.Matrix4().makeTranslation(dx, 0, dz); const rotation = new THREE.Matrix4().makeRotationY(isLeft ? rad : -rad); transform.multiply(translation).multiply(rotation); } m.multiply(transform); return m; }, [chain, piecesDef]);

            // ... Handlers ...
            const generateReport = () => { setViewMode('capturing'); };
            const handleCaptureReady = (url) => { setSnapshotUrl(url); setViewMode('report'); };
            
            // FIX PDF: Clonar elemento en un contenedor temporal sin restricciones CSS para evitar cortes
            const downloadPDF = () => { 
                const element = document.getElementById('printable-area'); 
                if (!element) return;

                // Crear contenedor temporal fuera del flujo 'fixed' de la app
                const container = document.createElement('div');
                container.style.position = 'absolute';
                container.style.top = '-9999px';
                container.style.left = '0';
                container.style.width = '1123px'; // Aprox A4 Landscape en pixels
                container.style.zIndex = '-1';
                
                // Clonar el nodo para no afectar la vista actual
                const clone = element.cloneNode(true);
                // Asegurar que el clon sea visible y negro sobre blanco
                clone.style.width = '100%';
                clone.style.height = 'auto';
                clone.style.color = '#000';
                clone.style.background = '#fff';
                
                container.appendChild(clone);
                document.body.appendChild(container);

                const opt = { 
                    margin: 10, 
                    filename: `ninco-track-${Date.now()}.pdf`, 
                    image: { type: 'jpeg', quality: 0.98 }, 
                    html2canvas: { scale: 2, useCORS: true, scrollY: 0, windowWidth: 1200 }, 
                    jsPDF: { unit: 'mm', format: 'a4', orientation: 'landscape' } 
                }; 
                
                if (window.html2pdf) { 
                    window.html2pdf().set(opt).from(clone).save().then(() => {
                        // Limpieza tras guardar
                        document.body.removeChild(container);
                    }).catch(err => {
                        console.error("PDF Error", err);
                        document.body.removeChild(container);
                    });
                } else { 
                    document.body.removeChild(container);
                    setConfirmModal({ message: "Librería PDF no cargada. Se intentará impresión básica.", onConfirm: () => { window.print(); setConfirmModal(null); }, isAlert: true }); 
                } 
            };

            const startBuilder = () => { setBoardSize({ width: parseFloat(inputSize.width), length: parseFloat(inputSize.length) }); setSegments([{ id: 1, pId: 'STD', dir: 1, type: 'START', pos: new THREE.Vector3(), rot: new THREE.Euler() }]); setSelId(1); setShowBoardConfig(false); if (window.Tone) { initAudio().catch(e => console.log("Audio init failed or deferred", e)); } };
            const add = (pId) => { if(viewMode!=='editor') return; const newId = Date.now() + Math.random(); setSegments(prev => [...prev, { id: newId, pId, dir: nextDir, type: 'PIECE' }]); setSelId(newId); };
            const del = () => { if(viewMode!=='editor') return; const f = segments.filter(s => s.id !== selId); setSegments(f); if(f.length > 0) setSelId(f[f.length-1].id); };
            const undo = () => { if(viewMode!=='editor') return; if(segments.length > 1) { const newSegs = segments.slice(0, -1); setSegments(newSegs); setSelId(newSegs[newSegs.length-1].id); } };
            const flip = () => { if(viewMode!=='editor') return; const s = segments.find(x => x.id === selId); if(s && piecesDef[s.pId].type === 'CURVE') { setSegments(segments.map(x => x.id === selId ? {...x, dir: x.dir * -1} : x)); } };
            const reset = () => { setConfirmModal({ message: "¿Seguro que quieres borrar todo el circuito y las decoraciones?", onConfirm: () => { setSegments([{ id: 1, pId: 'STD', dir: 1, type: 'START', pos: new THREE.Vector3(), rot: new THREE.Euler() }]); setPlacedDecos([]); setSelId(1); setConfirmModal(null); } }); };
            const handlePieceClick = (e, id) => { if(viewMode!=='editor' || appMode !== 'builder' || moveMode === 'track' || decoMode) return; e.stopPropagation(); setSelId(id); };
            const rotateBoard = () => { if (boardRef.current) { boardRef.current.rotation.z += Math.PI / 2; } };
            const spawnParallel = (direction) => { const selectedData = pieceMaps[selId]; if (!selectedData) return; const offset = direction === 'left' ? -systemSpecs.width : systemSpecs.width; const m = selectedData.mat.clone(); m.multiply(new THREE.Matrix4().makeTranslation(0, 0, offset)); const pos = new THREE.Vector3(); const rotQ = new THREE.Quaternion(); const scale = new THREE.Vector3(); m.decompose(pos, rotQ, scale); const rot = new THREE.Euler().setFromQuaternion(rotQ); const newId = Date.now(); setSegments(prev => [...prev, { id: newId, pId: 'STD', dir: 1, type: 'START', pos: pos, rot: rot }]); setSelId(newId); };
            const toggleSystem = () => { setConfirmModal({ message: "Cambiar de sistema reiniciará la pista actual. ¿Continuar?", onConfirm: () => { setCurrentSystem(s => s === 'ninco' ? 'scaleauto' : 'ninco'); setSegments([{ id: 1, pId: 'STD', dir: 1, type: 'START', pos: new THREE.Vector3(), rot: new THREE.Euler() }]); setConfirmModal(null); } }); };
            const updateStartPos = useCallback((id, newPos) => { setSegments(prev => { const newSegs = [...prev]; const index = newSegs.findIndex(s => s.id === id); if (index !== -1) { newSegs[index] = { ...newSegs[index], pos: newPos }; } return newSegs; }); }, []);
            const rotateStart = (deg) => { setSegments(prev => { const index = prev.findIndex(s => s.id === selId); if (index === -1) return prev; const newSegs = [...prev]; const currentRot = newSegs[index].rot; newSegs[index] = { ...newSegs[index], rot: new THREE.Euler(currentRot.x, currentRot.y + (deg * Math.PI / 180), currentRot.z) }; return newSegs; }); };

            const handleDecoObjUpload = (e) => { const file = e.target.files[0]; if (!file) return; const url = URL.createObjectURL(file); const name = file.name.split('.')[0].substring(0, 10); const newDeco = { id: `deco-${Date.now()}`, name: name, type: 'CUSTOM_DECO', customData: { obj: url, mtl: null }, storage: { objBlob: file, mtlBlob: null } }; setCustomDecos(prev => { const updated = [...prev, newDeco]; set('ninco-custom-decos', updated).catch(err => console.error("Err saving deco", err)); return updated; }); setActiveDecoId(newDeco.id); speak("Decoración importada"); e.target.value = ''; };
            const handleDecoMtlUpload = (e) => { const file = e.target.files[0]; if (!file) return; const url = URL.createObjectURL(file); if (activeDecoId) { setCustomDecos(prev => { const updated = prev.map(d => { if (d.id === activeDecoId) { return { ...d, customData: { ...d.customData, mtl: url }, storage: { ...d.storage, mtlBlob: file } }; } return d; }); set('ninco-custom-decos', updated); return updated; }); speak("Textura aplicada"); } e.target.value = ''; };
            const placeDecoration = (point) => { if (!activeDecoId) return; const newInstance = { instanceId: Date.now(), modelId: activeDecoId, position: [point.x, 0, point.z], rotation: [0, 0, 0], scale: 1.0 }; setPlacedDecos(prev => [...prev, newInstance]); setSelectedDecoInstance(newInstance.instanceId); speak("Objeto colocado"); };
            const updateDecoInstance = (id, prop, value) => { setPlacedDecos(prev => prev.map(d => { if (d.instanceId === id) { return { ...d, [prop]: value }; } return d; })); };
            const deleteDecoInstance = (e) => { if (e && e.stopPropagation) { e.stopPropagation(); e.nativeEvent?.stopImmediatePropagation(); } if(selectedDecoInstance) { setPlacedDecos(prev => prev.filter(d => d.instanceId !== selectedDecoInstance)); setSelectedDecoInstance(null); speak("Objeto borrado"); } };
            
            // --- GESTIÓN DE COCHES ---
            const [editablePresetCars, setEditablePresetCars] = useState(PRESET_CARS);
            
            const allCars = useMemo(() => [...editablePresetCars, ...customCars], [editablePresetCars, customCars]);
            const activeCarData = useMemo(() => allCars.find(c => c.id === selectedCarModelId) || editablePresetCars[0], [allCars, selectedCarModelId]);
            
            // Función CORREGIDA para actualizar specs de un coche
            const updateCarSpec = (category, updateValues) => {
                const updater = (prevCars) => prevCars.map(c => {
                    if (c.id === selectedCarModelId) {
                        const oldSpecs = c.specs || {};
                        const oldCategory = oldSpecs[category] || {};
                        const newCategory = { ...oldCategory, ...updateValues };
                        return { ...c, specs: { ...oldSpecs, [category]: newCategory } };
                    }
                    return c;
                });
                
                if (selectedCarModelId.startsWith('custom-')) {
                    setCustomCars(prev => {
                        const updated = updater(prev);
                        set('ninco-custom-cars', updated);
                        return updated;
                    });
                } else {
                    setEditablePresetCars(updater);
                }
            };

            const handleObjUpload = (e) => { const file = e.target.files[0]; if (!file) return; const url = URL.createObjectURL(file); const name = file.name.split('.')[0].substring(0, 10); const newCar = { id: `custom-${Date.now()}`, name: name, type: 'CUSTOM_OBJ', description: 'Importado', customData: { obj: url, mtl: null }, storage: { objBlob: file, mtlBlob: null }, specs: { offset: {x:0, y:0, z:0}, rotation: {y:0, z:0} } }; setCustomCars(prev => { const updated = [...prev, newCar]; set('ninco-custom-cars', updated).catch(err => console.error("Error guardando coche", err)); return updated; }); setSelectedCarModelId(newCar.id); speak("Coche importado"); e.target.value = ''; };
            const handleMtlUpload = (e) => { const file = e.target.files[0]; if (!file) return; const url = URL.createObjectURL(file); if (selectedCarModelId.startsWith('custom-')) { setCustomCars(prev => { const updated = prev.map(c => { if (c.id === selectedCarModelId) { return { ...c, customData: { ...c.customData, mtl: url }, storage: { ...c.storage, mtlBlob: file } }; } return c; }); set('ninco-custom-cars', updated).catch(err => console.error("Error guardando textura", err)); return updated; }); speak("Material aplicado"); } e.target.value = ''; };
            const handleImgUpload = (e) => { const file = e.target.files[0]; if (!file) return; const url = URL.createObjectURL(file); if (selectedCarModelId.startsWith('custom-')) { setCustomCars(prev => { const updated = prev.map(c => { if (c.id === selectedCarModelId) { return { ...c, customData: { ...c.customData, tex: url }, storage: { ...c.storage, texBlob: file } }; } return c; }); set('ninco-custom-cars', updated).catch(err => console.error("Error guardando imagen", err)); return updated; }); speak("Imagen aplicada"); } e.target.value = ''; };

            const startRaceSequence = () => { initAudio(); setRaceState('countdown'); setLightStep(0); setRaceData({ currentLap: 0, lastLapTime: 0, bestLap: 0, totalTime: 0, avgLap: 0 }); speak("Semáforo en marcha"); };
            const pauseRace = () => { setRaceState('paused'); speak("Pausa"); };
            const resumeRace = () => { setRaceState('racing'); speak("Continuamos"); };
            const restartRace = () => { setRaceState('idle'); setCarThrottle(0); setResetToken(prev => prev + 1); setRaceData({ currentLap: 0, lastLapTime: 0, bestLap: 0, totalTime: 0, avgLap: 0 }); speak("Vuelta a Inicio"); };
            const handleDerail = () => { if (driveMode === 'ai') return; setIsCrashed(true); playCrashSound(); speak("Salida de pista", true); setCarThrottle(0); setTimeout(() => setIsCrashed(false), 2000); };
            const toggleDriveMode = () => { const newMode = driveMode === 'manual' ? 'ai' : 'manual'; setDriveMode(newMode); speak(newMode === 'ai' ? "Modo IA activado" : "Control Manual", true); setCarThrottle(0); };
            const cycleLaps = () => { const idx = LAP_OPTIONS.indexOf(targetLaps); setTargetLaps(LAP_OPTIONS[(idx + 1) % LAP_OPTIONS.length]); };
            const addMotor = () => { const newMotor = { id: `custom-${Date.now()}`, name: 'Nuevo Motor', rpm: 20000, torque: 1.0, color: '#ffffff' }; const updated = [...motors, newMotor]; setMotors(updated); setSelectedMotor(newMotor); set('ninco-motors', updated); speak("Motor añadido"); };
            const addTire = () => { const newTire = { id: `custom-${Date.now()}`, name: 'Custom', grip: 1.0, color: '#ffffff', label: 'CUST' }; const updated = [...tires, newTire]; setTires(updated); setSelectedTire(newTire); set('ninco-tires', updated); speak("Neumático añadido"); };
            const clearSavedData = async () => { setConfirmModal({ message: "¿Borrar todos los coches, decoraciones y configuraciones personalizadas guardadas?", onConfirm: async () => { await set('ninco-custom-cars', []); await set('ninco-custom-decos', []); await set('ninco-motors', INITIAL_MOTORS); await set('ninco-tires', INITIAL_TIRES); setCustomCars([]); setCustomDecos([]); setMotors(INITIAL_MOTORS); setTires(INITIAL_TIRES); setSelectedCarModelId('std'); setConfirmModal(null); speak("Datos borrados"); } }); };
            const saveCircuit = () => { const data = { version: 1, system: currentSystem, board: boardSize, segments: segments, decorations: placedDecos }; const blob = new Blob([JSON.stringify(data)], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `circuito-${currentSystem}-${Date.now()}.json`; a.click(); URL.revokeObjectURL(url); speak("Circuito guardado"); };
            const loadCircuit = (e) => { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (event) => { try { const data = JSON.parse(event.target.result); if (data.segments && data.system) { setCurrentSystem(data.system); setBoardSize(data.board || { width: 244, length: 122 }); const restoredSegments = data.segments.map(s => { const newPos = s.pos ? new THREE.Vector3(s.pos.x, s.pos.y, s.pos.z) : undefined; const newRot = s.rot ? new THREE.Euler(s.rot._x !== undefined ? s.rot._x : s.rot.x, s.rot._y !== undefined ? s.rot._y : s.rot.y, s.rot._z !== undefined ? s.rot._z : s.rot.z, s.rot._order || s.rot.order || 'XYZ') : undefined; const cleanSegment = { ...s }; if (newPos) cleanSegment.pos = newPos; if (newRot) cleanSegment.rot = newRot; return cleanSegment; }); setSegments(restoredSegments); setSelId(restoredSegments[0].id); if (data.decorations && Array.isArray(data.decorations)) { setPlacedDecos(data.decorations); } speak("Circuito cargado"); } else { setConfirmModal({ message: "Formato de archivo no válido", onConfirm: () => setConfirmModal(null), isAlert: true }); } } catch (err) { console.error(err); setConfirmModal({ message: "Error al leer el archivo.", onConfirm: () => setConfirmModal(null), isAlert: true }); } e.target.value = ''; }; reader.readAsText(file); };
            
            useEffect(() => { let timeoutId; if (raceState === 'countdown' && lightStep >= 1 && lightStep <= 5) { playToneBeep("G4", "0.15"); } else if (raceState === 'racing' && lightStep === 6) { playToneStart(); raceStartTime.current = Date.now(); } return () => clearTimeout(timeoutId); }, [lightStep, raceState]);
            useEffect(() => { let interval; if (raceState === 'countdown') { interval = setInterval(() => { setLightStep(prev => { if (prev >= 5) { setRaceState('racing'); clearInterval(interval); return 6; } return prev + 1; }); }, 1000); } return () => clearInterval(interval); }, [raceState]);
            useEffect(() => { let int; if(raceState === 'racing') { int = setInterval(() => { setRaceData(prev => ({...prev, totalTime: (Date.now() - raceStartTime.current)/1000})); }, 100); } return () => clearInterval(int); }, [raceState]);
            
            // FIX: Lógica de vueltas blindada para evitar bucle de locutora
            const handleLap = (lapTime) => { 
                // Si la carrera ya ha terminado, IGNORAR cualquier cruce de meta extra
                if (raceState === 'finished') return;

                setRaceData(prev => { 
                    const newLap = prev.currentLap + 1; 
                    const isBestLap = (prev.bestLap === 0 || lapTime < prev.bestLap); 
                    const totalRecordedTime = (prev.avgLap * prev.currentLap) + lapTime; 
                    const newAvg = totalRecordedTime / newLap; 
                    
                    // Solo activar "Fin de Carrera" si estamos realmente COMPITIENDO ('racing')
                    // En modo 'idle' (práctica), las vueltas cuentan pero no terminan la sesión.
                    if (raceState === 'racing' && newLap >= targetLaps && targetLaps !== Infinity) { 
                        setRaceState('finished'); 
                        speak("Carrera finalizada", true); 
                        setCarThrottle(0); // Cortar motor
                    } else if (isBestLap && lapTime > 0) { 
                        speak(`Rápida, ${lapTime.toFixed(2)}`); 
                    } 
                    
                    return { ...prev, currentLap: newLap, lastLapTime: lapTime, bestLap: isBestLap ? lapTime : prev.bestLap, avgLap: newAvg }; 
                }); 
            };
            
            const handleTelemetry = (data) => { setTelemetry(data); };
            const formatTime = (t) => { const m = Math.floor(t / 60); const s = Math.floor(t % 60); const ms = Math.floor((t * 10) % 10); return `${m}:${s.toString().padStart(2, '0')}.${ms}`; };
            const isSelectionStart = useMemo(() => { const s = segments.find(seg => seg.id === selId); return s && s.type === 'START'; }, [selId, segments]);
            const activeDecoData = useMemo(() => customDecos.find(d => d.id === activeDecoId) || BASE_DECOS[0], [customDecos, activeDecoId]);
            const selectedDecoObject = useMemo(() => placedDecos.find(d => d.instanceId === selectedDecoInstance), [placedDecos, selectedDecoInstance]);

            return (
                <div className="app-container">
                    <div className={systemSpecs.headerClass}>
                        <div className="flex flex-col items-center">
                            <span className="neon-title-blur text-2xl tracking-widest">{systemSpecs.name} MANAGER</span>
                            <span className="text-[9px] font-normal opacity-70 tracking-widest">ARCADE PHYSICS SYSTEM</span>
                        </div>
                    </div>
                    <div className="tab-bar">
                        <div onClick={() => setAppMode('builder')} className={`tab-btn ${appMode === 'builder' ? 'active' : ''}`}><PenTool size={16} /> DISEÑADOR</div>
                        <div onClick={() => setAppMode('racer')} className={`tab-btn ${appMode === 'racer' ? 'active' : ''}`}><CarFront size={16} /> PILOTO 3D</div>
                    </div>

                    {confirmModal && (
                        <div className="absolute inset-0 z-[100] flex items-center justify-center bg-black/70 backdrop-blur-sm no-print animate-fade-in">
                            <div className="bg-slate-900 border border-slate-700 p-6 rounded-xl shadow-2xl max-w-sm w-full m-4 transform scale-100 transition-all">
                                <h3 className="text-xl font-bold text-white mb-2">{confirmModal.isAlert ? "Información" : "Confirmar Acción"}</h3>
                                <p className="text-slate-300 mb-6 font-medium">{confirmModal.message}</p>
                                <div className="flex gap-3 justify-end">
                                    {!confirmModal.isAlert && (
                                        <button onClick={() => setConfirmModal(null)} className="px-4 py-2 rounded bg-slate-700 hover:bg-slate-600 text-white font-bold transition">Cancelar</button>
                                    )}
                                    <button onClick={confirmModal.onConfirm} className="px-4 py-2 rounded bg-red-600 hover:bg-red-500 text-white font-bold transition shadow-lg">
                                        {confirmModal.isAlert ? "Entendido" : "Sí, continuar"}
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {previewData && (
                        <PreviewModal data={previewData} onClose={() => setPreviewData(null)} />
                    )}

                    {showBoardConfig && (
                        <div className="absolute inset-0 z-[200] flex items-center justify-center modal-overlay no-print">
                            <div className="bg-slate-900 border border-slate-700 p-8 rounded-xl shadow-2xl max-w-md w-full m-4">
                                <h2 className="text-2xl font-bold text-white mb-2 text-center">Configurar Tablero</h2>
                                <div className="space-y-4 mt-4">
                                    <div><label className="block text-sm font-bold text-slate-400 uppercase mb-1">Largo (cm)</label><input type="number" value={inputSize.width} onChange={e=>setInputSize({...inputSize, width: e.target.value})} className="w-full bg-slate-800 border-2 border-slate-600 rounded p-3 text-white text-lg font-bold" /></div>
                                    <div><label className="block text-sm font-bold text-slate-400 uppercase mb-1">Ancho (cm)</label><input type="number" value={inputSize.length} onChange={e=>setInputSize({...inputSize, length: e.target.value})} className="w-full bg-slate-800 border-2 border-slate-600 rounded p-3 text-white text-lg font-bold" /></div>
                                    <div className="pt-2">
                                        <label className="block text-sm font-bold text-slate-400 uppercase mb-1">Sistema de Pista</label>
                                        <div className="flex gap-2">
                                            <button onClick={()=>setCurrentSystem('ninco')} className={`flex-1 p-3 rounded font-bold border-2 transition ${currentSystem === 'ninco' ? 'bg-red-900/50 border-red-500 text-white' : 'bg-slate-800 border-slate-600 text-slate-500'}`}>NINCO (1:32)</button>
                                            <button onClick={()=>setCurrentSystem('scaleauto')} className={`flex-1 p-3 rounded font-bold border-2 transition ${currentSystem === 'scaleauto' ? 'bg-yellow-900/50 border-yellow-500 text-white' : 'bg-slate-800 border-slate-600 text-slate-500'}`}>SCALEAUTO (1:24)</button>
                                        </div>
                                    </div>
                                    <button onClick={startBuilder} className="w-full bg-blue-600 hover:bg-blue-700 text-white font-black text-xl py-4 rounded transition mt-4 shadow-lg border-b-4 border-blue-800 active:border-b-0 active:translate-y-1">EMPEZAR</button>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {viewMode === 'report' && (
                        <div className="report-view">
                            <div className="flex justify-between items-center w-full px-4 py-3 bg-white border-b border-gray-200 sticky top-0 z-10 no-print shadow-sm">
                                <button onClick={()=>setViewMode('editor')} className="flex items-center gap-2 bg-gray-200 text-gray-800 px-6 py-3 rounded hover:bg-gray-300 font-bold text-sm transition"><ArrowLeft size={18}/> VOLVER</button>
                                <button onClick={downloadPDF} className="flex items-center gap-2 bg-blue-600 text-white px-6 py-3 rounded hover:bg-blue-700 font-bold text-sm shadow transition"><FileDown size={18}/> DESCARGAR PDF</button>
                            </div>
                            <div id="printable-area" className="bg-white">
                                <div className="report-header" style={currentSystem === 'scaleauto' ? { background: '#475569', color: '#fbbf24', borderBottom: '4px solid #fbbf24' } : {}}>
                                    {systemSpecs.name} <span className="text-sm opacity-70 font-normal">INFORME</span>
                                </div>
                                <div className="report-content">
                                    <div className="flex flex-col w-full h-full bg-white gap-4 p-4">
                                        <div className="snapshot-wrapper"><div className="snapshot-container">{snapshotUrl && <img src={snapshotUrl} alt="Circuito" className="snapshot-img" />}</div></div>
                                        <div className="flex flex-col md:flex-row w-full gap-6">
                                            <div className="flex-1 p-3 border border-gray-200 rounded bg-gray-50"><h3 className="font-black text-lg mb-2 text-red-700 uppercase border-b-2 border-red-200 pb-1">Resumen</h3><div className="text-slate-800 flex flex-col gap-2"><div className="flex justify-between items-center text-base"><span>Cuerda Total:</span> <span className="font-bold text-xl">{stats.totalLen} m</span></div></div></div>
                                            <div className="flex-[1.5]"><h3 className="font-black text-lg mb-2 text-red-700 uppercase border-b-2 border-red-200 pb-1">Inventario</h3><table className="inv-table w-full text-slate-800 border border-gray-200"><thead><tr><th>Pieza</th><th className="text-center">Cant.</th></tr></thead><tbody>{stats.inventory.map(([name, count], i) => (<tr key={i}><td className="font-medium">{name}</td><td className="text-center font-bold bg-white">{count}</td></tr>))}<tr className="bg-gray-200 border-t-2 border-gray-400"><td className="font-black text-right text-gray-800">TOTAL</td><td className="text-center font-black text-black text-lg">{stats.totalPieces}</td></tr></tbody></table></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* CANVAS CONTAINER FIX: height-0 force flex calculation */}
                    <div className={`flex-1 relative bg-gradient-to-br from-slate-900 to-black overflow-hidden min-h-0 h-0 w-full ${viewMode==='report' ? 'hidden' : ''}`}>
                        <Canvas shadows dpr={[1, 2]} gl={{ antialias: true, preserveDrawingBuffer: true }}>
                            <PerspectiveCamera makeDefault fov={appMode === 'builder' ? 20 : 45} />
                            <OrbitControls makeDefault minDistance={10} maxDistance={3000} target={[0,0,0]} enabled={viewMode==='editor'} enableRotate={appMode === 'racer'} enableZoom={appMode === 'racer'} maxPolarAngle={appMode === 'racer' ? Math.PI / 2 - 0.1 : 0} />
                            <SceneManager appMode={appMode} viewMode={viewMode} setViewMode={setViewMode} onCaptureReady={handleCaptureReady} boardRef={boardRef} boardSize={boardSize} />
                            <CameraEventsListener enabled={appMode === 'builder'} />
                            <ambientLight intensity={0.7} />
                            <directionalLight position={[100, 200, 50]} intensity={1.5} castShadow />
                            <ErrorBoundary fallback={null}>
                                <Environment preset="city" />
                            </ErrorBoundary>
                            <group>
                                {boardSize.width > 0 && (<DraggableBoard ref={boardRef} width={boardSize.width} length={boardSize.length} enabled={moveMode === 'board' && viewMode === 'editor' && appMode === 'builder'} isDecoMode={decoMode} onBoardClick={decoMode ? placeDecoration : null} />)}
                                
                                {chain.map((s) => {
                                    if (s.type === 'START') {
                                        return (
                                            <StartPieceHandler 
                                                key={s.id} 
                                                id={s.id}
                                                position={s.pos} 
                                                onPosChange={updateStartPos} 
                                                isSelected={selId === s.id && viewMode === 'editor' && appMode === 'builder' && !decoMode}
                                                enabled={viewMode === 'editor' && appMode === 'builder'}
                                                dragEnabled={moveMode === 'track' && viewMode === 'editor' && appMode === 'builder'}
                                            >
                                                <group rotation={s.rot}>
                                                    <TrackMesh def={piecesDef[s.pId]} isLeft={s.dir === 1} isSelected={selId === s.id && viewMode==='editor' && appMode === 'builder' && !decoMode} onClick={(e) => handlePieceClick(e, s.id)} systemSpecs={systemSpecs} />
                                                    <FinishLine width={systemSpecs.width} />
                                                </group>
                                            </StartPieceHandler>
                                        );
                                    }
                                    return (
                                        <group key={s.id} position={s.pos} rotation={s.rot}>
                                            <TrackMesh def={piecesDef[s.pId]} isLeft={s.dir === 1} isSelected={selId === s.id && viewMode==='editor' && appMode === 'builder' && !decoMode} onClick={(e) => handlePieceClick(e, s.id)} systemSpecs={systemSpecs} />
                                        </group>
                                    );
                                })}

                                {viewMode==='editor' && appMode === 'builder' && !decoMode && (<group position={new THREE.Vector3().setFromMatrixPosition(pointerMatrix)} quaternion={new THREE.Quaternion().setFromRotationMatrix(pointerMatrix)}><mesh position={[0,1,0]}><coneGeometry args={[1, 2, 8]} /><meshBasicMaterial color="#22c55e" /></mesh></group>)}
                                
                                {/* RENDERIZADO DE DECORACIONES INTERACTIVAS */}
                                {placedDecos.map(d => {
                                    // Buscar modelo
                                    let modelInfo = customDecos.find(c => c.id === d.modelId);
                                    // Si no encuentra custom, buscar base
                                    if (!modelInfo) modelInfo = BASE_DECOS.find(b => b.id === d.modelId);

                                    return (
                                        <DraggableDecoration
                                            key={d.instanceId}
                                            data={d}
                                            modelInfo={modelInfo}
                                            isSelected={selectedDecoInstance === d.instanceId}
                                            isDecoMode={decoMode}
                                            onUpdate={updateDecoInstance}
                                            onSelect={setSelectedDecoInstance}
                                        />
                                    );
                                })}
                                
                                {carEnabled && chain.length > 0 && viewMode === 'editor' && (
                                    <AnimatedCar 
                                        chain={chain} throttle={carThrottle} 
                                        // FIX: Detener simulación si está en pausa, cuenta atrás O FINALIZADA
                                        isPlaying={raceState !== 'paused' && raceState !== 'countdown' && raceState !== 'finished'} 
                                        isPaused={raceState === 'paused'}
                                        selectedLane={selectedLane} onLap={handleLap} motor={selectedMotor} tires={selectedTire}
                                        voltage={selectedVoltage} weight={carWeight} onDerail={handleDerail} driveMode={driveMode} onTelemetry={handleTelemetry} totalLaps={targetLaps} systemId={currentSystem}
                                        resetToken={resetToken}
                                        carModelId={selectedCarModelId}
                                        customData={activeCarData?.customData}
                                        modelRotation={activeCarData?.specs?.rotation?.y || 0}
                                        modelRotationZ={activeCarData?.specs?.rotation?.z || 0}
                                        offsetY={activeCarData?.specs?.offset?.y || 0}
                                        offsetZ={activeCarData?.specs?.offset?.z || 0}
                                    />
                                )}
                            </group>
                        </Canvas>

                        <TouchControlsOverlay enabled={appMode === 'builder' && viewMode === 'editor'} />

                        {/* ... RACER HUD ... */}
                        {carEnabled && viewMode === 'editor' && appMode === 'racer' && (
                            <>
                                <div className="absolute top-[52px] left-0 w-full flex flex-col z-40 p-2 items-center">
                                    {/* ... existing hud overlay ... */}
                                    <div className="flex justify-between items-stretch gap-0 neon-panel-full p-0 rounded-xl overflow-hidden w-full max-w-4xl shadow-2xl">
                                        {/* ... TELEMETRY ... */}
                                        <div className="flex flex-col flex-1 min-w-[200px] p-3 bg-gradient-to-r from-slate-900/80 to-transparent">
                                            <div className="flex items-center gap-2 mb-3 border-b border-cyan-500/30 pb-1">
                                                <Activity size={14} className="text-cyan-400 animate-pulse"/>
                                                <span className="text-[10px] font-black text-cyan-400 uppercase tracking-widest drop-shadow-[0_0_5px_cyan]">VELOCIDAD REAL</span>
                                            </div>
                                            <div className="flex justify-between items-end mb-1">
                                                <span className="text-[9px] font-bold text-slate-400">VELOCIDAD</span>
                                                <span className="text-[9px] font-bold text-red-400">LÍMITE: {telemetry.limit.toFixed(1)}</span>
                                            </div>
                                            <div className="relative w-full h-4 bg-slate-900 rounded border border-slate-700 mb-3 group">
                                                <div style={{width: `${Math.min(100, (telemetry.limit/25)*100)}%`}} className="absolute top-0 left-0 h-full bg-red-900/20 border-r border-red-500/50 transition-all duration-300"></div>
                                                <div style={{width: `${Math.min(100, (telemetry.speed/25)*100)}%`}} className={`absolute top-0 left-0 h-full transition-all duration-75 shadow-[0_0_10px_cyan] ${telemetry.speed > telemetry.limit ? 'bg-red-500 shadow-[0_0_15px_red]' : 'bg-cyan-400'}`}></div>
                                                <span className="absolute inset-0 flex items-center justify-center text-[10px] font-black text-white mix-blend-difference z-10 font-mono tracking-wider">{telemetry.speed.toFixed(1)} KM/H</span>
                                            </div>
                                            <div className="flex items-center gap-2 mb-2">
                                                <span className="text-[9px] font-bold text-slate-400 w-8">THROT</span>
                                                <div className="flex-1 h-1.5 bg-slate-800 rounded-full overflow-hidden">
                                                    <div style={{width: `${telemetry.throttle*100}%`}} className="h-full bg-green-500 shadow-[0_0_8px_green]"></div>
                                                </div>
                                            </div>
                                            <div className="grid grid-cols-2 gap-2 mt-auto">
                                                <div className="bg-slate-800/50 rounded p-1 flex flex-col items-center border border-slate-700">
                                                    <span className="text-[8px] text-slate-500 font-bold">FUERZA G</span>
                                                    <span className="text-sm font-mono font-bold text-white">{telemetry.gForce.toFixed(2)}G</span>
                                                </div>
                                                <div className="bg-slate-800/50 rounded p-1 flex flex-col items-center border border-slate-700">
                                                    <span className="text-[8px] text-slate-500 font-bold">AGARRE</span>
                                                    <span className={`text-sm font-mono font-bold ${telemetry.gripLimit > 90 ? 'text-red-500 animate-pulse' : 'text-white'}`}>{telemetry.gripLimit.toFixed(0)}%</span>
                                                </div>
                                            </div>
                                        </div>

                                        <div className="w-px bg-gradient-to-b from-transparent via-cyan-500/50 to-transparent"></div>

                                        {/* ... CENTER DISPLAY ... */}
                                        <div className="flex-[1.2] flex flex-col items-center justify-between p-2 relative bg-black/20">
                                            <div className="flex gap-4 bg-black/80 px-8 py-2.5 rounded-b-2xl border-x border-b border-slate-700/50 shadow-lg mb-2 mt-1 transform scale-125 origin-top">
                                                {[1, 2, 3, 4, 5].map(i => (
                                                    <div key={i} className={`w-6 h-6 rounded-full transition-all duration-75 border border-slate-600 ${lightStep >= 6 ? 'bg-green-500 shadow-[0_0_20px_#22c55e]' : (lightStep >= i ? 'bg-red-600 shadow-[0_0_20px_#ef4444]' : 'bg-slate-900')}`}></div>
                                                ))}
                                            </div>

                                            <div onClick={cycleLaps} className="flex flex-col items-center justify-center flex-1 cursor-pointer group hover:bg-white/5 rounded-xl transition-all py-1 w-full" title="Clic para cambiar vueltas objetivo">
                                                <div className="flex items-center gap-2">
                                                    <span className="text-[10px] font-bold text-slate-500 tracking-[0.4em] uppercase group-hover:text-cyan-400 transition-colors">VUELTA</span>
                                                    <RefreshCw size={10} className="text-slate-600 group-hover:text-cyan-400 opacity-0 group-hover:opacity-100 transition-all"/>
                                                </div>
                                                <div className="flex items-baseline leading-none mt-1 select-none">
                                                    <span className="text-7xl font-black text-white italic tracking-tighter drop-shadow-[0_4px_0_rgba(0,0,0,0.5)]" style={{fontFamily:'Arial Black, sans-serif'}}>{raceData.currentLap}</span>
                                                    <span className="text-2xl font-bold text-slate-600 group-hover:text-white transition-colors">/{targetLaps===Infinity?'∞':targetLaps}</span>
                                                </div>
                                                <div className="mt-3 px-4 py-1 bg-cyan-900/30 border border-cyan-500/30 rounded text-[10px] font-bold text-cyan-200 uppercase tracking-wider">
                                                    {telemetry.section || "PISTA"}
                                                </div>
                                            </div>

                                            {isCrashed && (
                                                <div className="absolute inset-0 bg-red-900/80 flex items-center justify-center backdrop-blur-sm z-50 animate-pulse">
                                                    <span className="text-white font-black text-xl tracking-widest border-4 border-white px-4 py-2 transform -rotate-6">CRASH!</span>
                                                </div>
                                            )}
                                        </div>

                                        <div className="w-px bg-gradient-to-b from-transparent via-cyan-500/50 to-transparent"></div>

                                        {/* ... RIGHT PANEL ... */}
                                        <div className="flex flex-col flex-1 min-w-[200px] p-3 bg-gradient-to-l from-slate-900/80 to-transparent">
                                            <div className="flex items-center justify-end gap-2 mb-3 border-b border-cyan-500/30 pb-1">
                                                <span className="text-[10px] font-black text-cyan-400 uppercase tracking-widest drop-shadow-[0_0_5px_cyan]">TIEMPOS</span>
                                                <Clock size={14} className="text-cyan-400"/>
                                            </div>

                                            <div className="flex flex-col gap-1.5 w-full">
                                                <div className="flex justify-between items-center bg-slate-800/30 px-2 py-1 rounded">
                                                    <span className="text-[9px] font-bold text-slate-400">TOTAL</span>
                                                    <span className="font-mono font-bold text-white text-sm">{formatTime(raceData.totalTime)}</span>
                                                </div>
                                                <div className="flex justify-between items-center bg-slate-800/30 px-2 py-1 rounded">
                                                    <span className="text-[9px] font-bold text-yellow-500">MEJOR</span>
                                                    <span className="font-mono font-bold text-yellow-400 text-sm">{raceData.bestLap > 0 ? raceData.bestLap.toFixed(3) : '--.---'}</span>
                                                </div>
                                                <div className="flex justify-between items-center bg-slate-800/30 px-2 py-1 rounded">
                                                    <span className="text-[9px] font-bold text-slate-400">ÚLTIMA</span>
                                                    <span className="font-mono font-bold text-slate-300 text-sm">{raceData.lastLapTime > 0 ? raceData.lastLapTime.toFixed(3) : '--.---'}</span>
                                                </div>
                                                <div className="flex justify-between items-center bg-slate-800/30 px-2 py-1 rounded border-l-2 border-blue-500">
                                                    <span className="text-[9px] font-bold text-blue-400">MEDIA</span>
                                                    <span className="font-mono font-bold text-blue-200 text-sm">{raceData.avgLap > 0 ? raceData.avgLap.toFixed(3) : '--.---'}</span>
                                                </div>
                                            </div>

                                            <div className="flex gap-1 mt-auto pt-2">
                                                <button onClick={toggleDriveMode} className={`flex-1 py-1 rounded text-[9px] font-bold uppercase transition border ${driveMode === 'ai' ? 'bg-blue-600 border-blue-400 text-white' : 'bg-transparent border-slate-600 text-slate-400'}`}>
                                                    {driveMode}
                                                </button>
                                                
                                                <div className="flex gap-1 flex-1">
                                                    {raceState === 'countdown' ? (
                                                        <button disabled className="flex items-center justify-center px-4 py-1 rounded text-white/50 font-black text-xs transition bg-slate-800 border border-slate-700 uppercase tracking-tight w-full cursor-not-allowed">
                                                            PREPARADOS...
                                                        </button>
                                                    ) : (
                                                        <>
                                                            {(raceState === 'idle' || raceState === 'finished') && (
                                                                <button onClick={startRaceSequence} className="flex items-center justify-center px-4 py-1 rounded text-white font-black text-xs transition shadow-lg bg-green-600 hover:bg-green-500 border border-green-700 uppercase tracking-tight flex-1" title="Iniciar Carrera">
                                                                    INICIAR
                                                                </button>
                                                            )}

                                                            {raceState === 'racing' && (
                                                                <button onClick={pauseRace} className="flex items-center justify-center px-4 py-1 rounded text-white font-black text-xs transition shadow-lg bg-orange-600 hover:bg-orange-500 border border-orange-700 uppercase tracking-tight flex-1" title="Pausar">
                                                                    <Pause size={14} className="mr-1"/> PAUSA
                                                                </button>
                                                            )}

                                                            {raceState === 'paused' && (
                                                                <>
                                                                    <button onClick={resumeRace} className="flex items-center justify-center px-2 py-1 rounded text-white font-black text-[10px] transition shadow-lg bg-blue-600 hover:bg-blue-500 border border-blue-700 uppercase tracking-tight flex-1" title="Continuar">
                                                                        <Play size={12} className="mr-1"/> SEGUIR
                                                                    </button>
                                                                    <button onClick={restartRace} className="flex items-center justify-center px-2 py-1 rounded text-white font-black text-[10px] transition shadow-lg bg-red-600 hover:bg-red-500 border border-red-700 uppercase tracking-tight flex-1" title="Reiniciar">
                                                                        <RotateCcw size={12} className="mr-1"/> REINICIAR
                                                                    </button>
                                                                </>
                                                            )}
                                                        </>
                                                    )}
                                                </div>

                                                <button onClick={() => setShowSetup(!showSetup)} className="p-1.5 rounded border border-slate-600 text-slate-400 hover:text-white hover:bg-slate-700"><Settings2 size={14}/></button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div className="absolute bottom-0 left-0 w-full z-50 flex flex-col justify-end pointer-events-none">
                                    {showSetup && (
                                        /* FIX: Scroll interno y altura máxima para que no se coma la pantalla en móvil */
                                        <div className="pointer-events-auto bg-slate-900/95 border-t border-slate-700 backdrop-blur-md pb-safe animate-slide-up transition-all max-h-[50vh] overflow-y-auto">
                                            <div className="flex justify-between items-center px-3 py-1 bg-slate-800 border-b border-slate-700 sticky top-0 z-10">
                                                <span className="text-[10px] font-bold text-slate-300 uppercase tracking-wider">Taller & Setup</span>
                                                <div className="flex items-center gap-2">
                                                    <button onClick={clearSavedData} className="text-[9px] font-bold text-red-400 hover:text-red-300 uppercase flex items-center gap-1"><Database size={10}/> Borrar Datos</button>
                                                    <button onClick={()=>setShowSetup(false)}><X size={14} className="text-slate-400 hover:text-white"/></button>
                                                </div>
                                            </div>

                                            <div className="px-2 py-2 border-b border-slate-800">
                                                <div className="flex justify-between items-end mb-1 px-1">
                                                    <span className="text-[9px] font-bold text-slate-500 uppercase">Garaje ({activeCarData.name})</span>
                                                </div>
                                                <div className="flex gap-2 overflow-x-auto pb-2 scrollbar-hide snap-x items-center">
                                                    {allCars.map(car => (
                                                        <div key={car.id} onClick={() => setSelectedCarModelId(car.id)} className={`cursor-pointer snap-start min-w-[90px] p-2 rounded border flex flex-col items-center justify-center gap-1 transition relative overflow-hidden group ${selectedCarModelId === car.id ? 'bg-slate-800 border-cyan-500 ring-1 ring-cyan-500/50' : 'border-slate-700 bg-slate-800/50 hover:bg-slate-800'}`}>
                                                            {/* Preview Button */}
                                                            <button 
                                                                onClick={(e) => { e.stopPropagation(); setPreviewData({ type: 'CAR', subType: car.type, color: selectedLane === 1 ? '#ef4444' : '#3b82f6', obj: car.customData?.obj, mtl: car.customData?.mtl, tex: car.customData?.tex, name: car.name }); }}
                                                                className="absolute top-1 right-1 p-1 bg-black/50 hover:bg-cyan-600 rounded-full text-white opacity-0 group-hover:opacity-100 transition-all z-10"
                                                                title="Vista Previa 3D"
                                                            >
                                                                <Eye size={10} />
                                                            </button>

                                                            {car.id.startsWith('custom-') && <div className="absolute top-0 left-0 bg-blue-500 text-white text-[6px] font-black px-1">IMP</div>}
                                                            <div className="w-12 h-6 bg-gradient-to-r from-gray-700 to-gray-600 rounded flex items-center justify-center text-[8px] font-bold text-white shadow-sm pointer-events-none">
                                                                {car.type === 'TRUCK' ? <Truck size={12}/> : (car.type === 'CUSTOM_OBJ' ? <FileBox size={12}/> : (car.type === 'CLASSIC' ? <History size={12}/> : (car.type === 'CUSTOM' ? <Upload size={12}/> : car.type)))}
                                                            </div>
                                                            <span className="text-[9px] font-bold text-slate-300 whitespace-nowrap pointer-events-none">{car.name}</span>
                                                            <span className="text-[8px] text-slate-500 text-center leading-tight pointer-events-none">{car.description || 'Importado'}</span>
                                                        </div>
                                                    ))}
                                                    
                                                    <div className="flex flex-col gap-1 ml-2 border-l border-slate-700 pl-2">
                                                        <input type="file" ref={objInputRef} onChange={handleObjUpload} accept=".obj" className="hidden" />
                                                        <button onClick={() => objInputRef.current.click()} className="flex items-center gap-1 px-2 py-1 bg-blue-700 hover:bg-blue-600 rounded text-[9px] font-bold text-white transition whitespace-nowrap">
                                                            <Plus size={10} /> NUEVO COCHE (OBJ)
                                                        </button>
                                                        
                                                        <input type="file" ref={mtlInputRef} onChange={handleMtlUpload} accept=".mtl" className="hidden" />
                                                        <button onClick={() => mtlInputRef.current.click()} className="flex items-center gap-1 px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded text-[9px] font-bold text-white transition whitespace-nowrap">
                                                            <Upload size={10} /> MATERIAL (MTL)
                                                        </button>
                                                        
                                                        <input type="file" ref={imgInputRef} onChange={handleImgUpload} accept="image/png, image/jpeg" className="hidden" />
                                                        <button onClick={() => imgInputRef.current.click()} className="flex items-center gap-1 px-2 py-1 bg-slate-700 hover:bg-green-600 rounded text-[9px] font-bold text-white transition whitespace-nowrap">
                                                            <ImageIcon size={10} /> IMAGEN (JPG/PNG)
                                                        </button>
                                                    </div>
                                                </div>
                                            </div>

                                            {/* --- ROTACIÓN MANUAL DEL MODELO --- */}
                                            <div className="px-3 py-2 border-b border-slate-800 flex flex-col gap-2 bg-slate-900/50">
                                                {/* ROTACIÓN Y (DIRECCIÓN) */}
                                                <div className="flex items-center gap-4">
                                                    <div className="flex flex-col flex-1">
                                                        <div className="flex justify-between items-center mb-1">
                                                            <span className="text-[9px] font-bold text-slate-400 uppercase flex items-center gap-1"><RotateCw size={10}/> ROTACIÓN MODELO (EJE Y)</span>
                                                            <span className="text-[9px] font-mono text-cyan-400">{activeCarData?.specs?.rotation?.y || 0}°</span>
                                                        </div>
                                                        <input 
                                                            type="range" min="0" max="360" step="5" 
                                                            value={activeCarData?.specs?.rotation?.y || 0} 
                                                            onChange={(e) => updateCarSpec('rotation', { y: parseInt(e.target.value) })}
                                                            className="w-full h-1.5 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-cyan-500"
                                                        />
                                                    </div>
                                                    <button 
                                                        onClick={() => updateCarSpec('rotation', { y: ((activeCarData?.specs?.rotation?.y || 0) + 180) % 360 })} 
                                                        className="px-3 py-1 bg-slate-700 hover:bg-slate-600 rounded text-[9px] font-bold text-white transition border border-slate-600 shadow-sm"
                                                    >
                                                        GIRAR 180°
                                                    </button>
                                                </div>

                                                {/* ROTACIÓN Z (VUELCO) */}
                                                <div className="flex items-center gap-4 border-t border-slate-800/50 pt-2">
                                                    <div className="flex flex-col flex-1">
                                                        <div className="flex justify-between items-center mb-1">
                                                            <span className="text-[9px] font-bold text-slate-400 uppercase flex items-center gap-1"><RotateCw size={10}/> ROTACIÓN EJE Z (Vuelco)</span>
                                                            <span className="text-[9px] font-mono text-cyan-400">{activeCarData?.specs?.rotation?.z || 0}°</span>
                                                        </div>
                                                        <input 
                                                            type="range" min="-180" max="180" step="90" 
                                                            value={activeCarData?.specs?.rotation?.z || 0} 
                                                            onChange={(e) => updateCarSpec('rotation', { z: parseInt(e.target.value) })}
                                                            className="w-full h-1.5 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-cyan-500"
                                                        />
                                                    </div>
                                                    <button 
                                                        onClick={() => updateCarSpec('rotation', { z: ((activeCarData?.specs?.rotation?.z || 0) + 90) % 360 })} 
                                                        className="px-3 py-1 bg-slate-700 hover:bg-slate-600 rounded text-[9px] font-bold text-white transition border border-slate-600 shadow-sm"
                                                    >
                                                        +90°
                                                    </button>
                                                </div>

                                                {/* ALTURA (OFFSET Y) */}
                                                <div className="flex items-center gap-4 border-t border-slate-800/50 pt-2">
                                                    <div className="flex flex-col flex-1">
                                                        <div className="flex justify-between items-center mb-1">
                                                            <span className="text-[9px] font-bold text-slate-400 uppercase flex items-center gap-1"><ArrowUp size={10}/> ALTURA CHASIS (EJE Y)</span>
                                                            <span className="text-[9px] font-mono text-cyan-400">{activeCarData?.specs?.offset?.y > 0 ? '+' : ''}{(activeCarData?.specs?.offset?.y || 0).toFixed(2)}</span>
                                                        </div>
                                                        <input 
                                                            type="range" min="-2" max="5" step="0.1" 
                                                            value={activeCarData?.specs?.offset?.y || 0} 
                                                            onChange={(e) => updateCarSpec('offset', { y: parseFloat(e.target.value) })}
                                                            className="w-full h-1.5 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-cyan-500"
                                                        />
                                                    </div>
                                                    <button 
                                                        onClick={() => updateCarSpec('offset', { y: 0 })} 
                                                        className="px-3 py-1 bg-slate-700 hover:bg-slate-600 rounded text-[9px] font-bold text-white transition border border-slate-600 shadow-sm"
                                                    >
                                                        RESET
                                                    </button>
                                                </div>

                                                {/* CENTRADO LATERAL (EJE Z) - RANGO AUMENTADO */}
                                                <div className="flex items-center gap-4 border-t border-slate-800/50 pt-2">
                                                    <div className="flex flex-col flex-1">
                                                        <div className="flex justify-between items-center mb-1">
                                                            <span className="text-[9px] font-bold text-slate-400 uppercase flex items-center gap-1"><ArrowLeftRight size={10}/> CENTRADO LATERAL (EJE Z)</span>
                                                            <span className="text-[9px] font-mono text-cyan-400">{activeCarData?.specs?.offset?.z > 0 ? '+' : ''}{(activeCarData?.specs?.offset?.z || 0).toFixed(2)}</span>
                                                        </div>
                                                        <input 
                                                            type="range" min="-15" max="15" step="0.1" 
                                                            value={activeCarData?.specs?.offset?.z || 0} 
                                                            onChange={(e) => updateCarSpec('offset', { z: parseFloat(e.target.value) })}
                                                            className="w-full h-1.5 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-cyan-500"
                                                        />
                                                    </div>
                                                    <button 
                                                        onClick={() => updateCarSpec('offset', { z: 0 })} 
                                                        className="px-3 py-1 bg-slate-700 hover:bg-slate-600 rounded text-[9px] font-bold text-white transition border border-slate-600 shadow-sm"
                                                    >
                                                        CENTRO
                                                    </button>
                                                </div>
                                            </div>

                                            <div className="px-2 py-2 border-b border-slate-800">
                                                <div className="flex justify-between items-end mb-1 px-1">
                                                    <span className="text-[9px] font-bold text-slate-500 uppercase">Motor ({selectedMotor.name})</span>
                                                </div>
                                                <div className="flex gap-2 overflow-x-auto pb-2 scrollbar-hide snap-x">
                                                    {motors.map(m => (
                                                        <button key={m.id} onClick={() => setSelectedMotor(m)} className={`snap-start min-w-[70px] p-1.5 rounded border flex flex-col items-center justify-center gap-1 transition ${selectedMotor.id === m.id ? 'bg-slate-800 border-yellow-500 ring-1 ring-yellow-500/50' : 'border-slate-700 bg-slate-800/50 hover:bg-slate-800'}`}>
                                                            <div className="scale-75"><MotorIcon color={m.color} /></div>
                                                            <span className="text-[8px] font-bold text-slate-300 whitespace-nowrap">{m.name.split(' ')[1] || m.name}</span>
                                                            <span className="text-[8px] text-slate-500 font-mono">{m.rpm/1000}k</span>
                                                        </button>
                                                    ))}
                                                    <button onClick={addMotor} className="snap-start min-w-[70px] p-1.5 rounded border border-dashed border-slate-600 flex flex-col items-center justify-center gap-1 hover:bg-slate-800 text-slate-500 hover:text-green-400 transition">
                                                        <Plus size={16}/> <span className="text-[8px] font-bold">AÑADIR</span>
                                                    </button>
                                                </div>
                                            </div>

                                            <div className="px-2 py-2 border-b border-slate-800">
                                                <div className="flex justify-between items-end mb-1 px-1">
                                                    <span className="text-[9px] font-bold text-slate-500 uppercase">Gomas ({selectedTire.label})</span>
                                                </div>
                                                <div className="flex gap-2 overflow-x-auto pb-2 scrollbar-hide snap-x">
                                                    {tires.map(t => (
                                                        <button key={t.id} onClick={() => setSelectedTire(t)} className={`snap-start min-w-[60px] p-1.5 rounded border flex flex-col items-center justify-center gap-1 transition ${selectedTire.id === t.id ? 'bg-slate-800 border-blue-500 ring-1 ring-blue-500/50' : 'border-slate-700 bg-slate-800/50 hover:bg-slate-800'}`}>
                                                            <div className="scale-75"><TireIcon color={t.color} label={t.label} /></div>
                                                            <span className="text-[8px] font-bold text-slate-300">{t.name}</span>
                                                        </button>
                                                    ))}
                                                    <button onClick={addTire} className="snap-start min-w-[60px] p-1.5 rounded border border-dashed border-slate-600 flex flex-col items-center justify-center gap-1 hover:bg-slate-800 text-slate-500 hover:text-green-400 transition">
                                                        <Plus size={16}/> <span className="text-[8px] font-bold">NUEVO</span>
                                                    </button>
                                                </div>
                                            </div>

                                            <div className="px-3 py-2 flex items-center gap-4 bg-slate-900">
                                                <div className="flex items-center gap-2 flex-1">
                                                    <Zap size={12} className="text-yellow-500"/>
                                                    <div className="flex bg-slate-800 rounded p-0.5 flex-1">
                                                        {VOLTAGES.map(v => (
                                                            <button key={v} onClick={() => setSelectedVoltage(v)} className={`flex-1 text-[9px] font-bold py-1 rounded transition ${selectedVoltage === v ? 'bg-yellow-600 text-white shadow' : 'text-slate-500 hover:text-white'}`}>{v}V</button>
                                                        ))}
                                                    </div>
                                                </div>
                                                <div className="flex items-center gap-2 flex-[1.5]">
                                                    <Weight size={12} className="text-blue-400"/>
                                                    <input type="range" min="60" max="140" step="1" value={carWeight} onChange={e=>setCarWeight(parseInt(e.target.value))} className="flex-1 h-1.5 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500"/>
                                                    <span className="text-[9px] font-mono text-blue-400 w-6 text-right">{carWeight}g</span>
                                                </div>
                                            </div>
                                        </div>
                                    )}

                                    <div className="pointer-events-auto bg-black/80 backdrop-blur border-t border-slate-700 p-2 pb-safe flex gap-3 items-center">
                                        {/* ... existing controls ... */}
                                        <div className="flex items-center gap-2 flex-1 h-14">
                                            <button 
                                                onClick={() => !isCrashed && driveMode === 'manual' && setCarThrottle(t => Math.max(0, parseFloat((t - 0.1).toFixed(1))))} 
                                                disabled={driveMode === 'ai'} 
                                                className="w-14 h-full rounded bg-slate-800 hover:bg-slate-700 text-white z-30 flex items-center justify-center border border-slate-600 font-bold active:scale-95 transition shadow-lg"
                                            >
                                                <Minus size={24} />
                                            </button>
                                            
                                            <div className="flex-1 h-full bg-slate-900 rounded-lg border border-slate-700 relative overflow-hidden mx-1">
                                                <div className="absolute inset-0 z-0 flex justify-between px-2 opacity-20 pointer-events-none">
                                                    {[...Array(9)].map((_,i)=><div key={i} className="w-px h-full bg-white"></div>)}
                                                </div>
                                                <div className="absolute inset-0 bg-gradient-to-r from-orange-900/60 to-red-600/60 z-0 origin-left transition-transform duration-75" style={{transform: `scaleX(${carThrottle})`}}></div>
                                                
                                                <input 
                                                    type="range" min="0" max="1" step="0.1" 
                                                    value={carThrottle} 
                                                    disabled={driveMode === 'ai'} 
                                                    onChange={(e) => !isCrashed && driveMode === 'manual' && setCarThrottle(parseFloat(e.target.value))} 
                                                    className={`absolute inset-0 w-full h-full opacity-0 cursor-pointer z-20`}
                                                />
                                                
                                                <div className="absolute inset-0 flex flex-col items-center justify-center pointer-events-none z-10">
                                                    <span className="text-[9px] font-bold text-slate-400 uppercase leading-none mb-1">THROTTLE</span>
                                                    <span className={`text-2xl font-black leading-none ${driveMode === 'ai' ? 'text-blue-400' : 'text-orange-400'}`}>
                                                        {driveMode === 'ai' ? 'AUTO' : `${(carThrottle * 100).toFixed(0)}%`}
                                                    </span>
                                                </div>
                                            </div>
                                            
                                            <button 
                                                onClick={() => !isCrashed && driveMode === 'manual' && setCarThrottle(t => Math.min(1, parseFloat((t + 0.1).toFixed(1))))} 
                                                disabled={driveMode === 'ai'} 
                                                className="w-14 h-full rounded bg-slate-800 hover:bg-slate-700 text-white z-30 flex items-center justify-center border border-slate-600 font-bold active:scale-95 transition shadow-lg"
                                            >
                                                <Plus size={24} />
                                            </button>
                                        </div>
                                        
                                        <div className="flex flex-col gap-1 bg-slate-900 rounded p-1 border border-slate-800 h-14 w-16 justify-center">
                                            <button onClick={() => { setSelectedLane(1); speak("Carril 1"); }} className={`flex-1 w-full text-[10px] font-bold rounded flex items-center justify-center transition ${selectedLane === 1 ? 'bg-red-600 text-white shadow-lg ring-1 ring-red-400' : 'bg-slate-800 text-slate-500 hover:bg-slate-700'}`}>L1</button>
                                            <button onClick={() => { setSelectedLane(2); speak("Carril 2"); }} className={`flex-1 w-full text-[10px] font-bold rounded flex items-center justify-center transition ${selectedLane === 2 ? 'bg-blue-600 text-white shadow-lg ring-1 ring-blue-400' : 'bg-slate-800 text-slate-500 hover:bg-slate-700'}`}>L2</button>
                                        </div>
                                    </div>
                                </div>
                            </>
                        )}
                        {/* ... existing builder tools ... */}
                        {viewMode==='editor' && appMode === 'builder' && boardSize.width > 0 && (
                            <div className="absolute top-4 left-4 flex flex-col gap-1 bg-slate-900/95 p-1.5 rounded-lg border border-slate-700 z-50 shadow-xl pointer-events-auto">
                                <div className="text-[9px] font-bold text-slate-500 uppercase px-1 mb-1 tracking-wider border-b border-slate-800 pb-1">Herramientas</div>
                                <div className="flex flex-col gap-1">
                                    <button 
                                        onClick={() => setMoveMode(m => m === 'board' ? 'none' : 'board')} 
                                        disabled={decoMode}
                                        className={`p-2 rounded transition flex items-center justify-between gap-3 min-w-[130px] ${moveMode === 'board' ? 'bg-green-600 text-white shadow' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 hover:text-white disabled:opacity-50'}`}
                                    >
                                        <div className="flex items-center gap-2">
                                            <LayoutTemplate size={16} />
                                            <span className="text-[10px] font-bold uppercase">Mover Tablero</span>
                                        </div>
                                        {moveMode === 'board' && <div className="w-2 h-2 rounded-full bg-white animate-pulse"></div>}
                                    </button>
                                    
                                    <button 
                                        onClick={() => setMoveMode(m => m === 'track' ? 'none' : 'track')} 
                                        disabled={decoMode}
                                        className={`p-2 rounded transition flex items-center justify-between gap-3 min-w-[130px] ${moveMode === 'track' ? 'bg-yellow-600 text-white shadow' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 hover:text-white disabled:opacity-50'}`}
                                    >
                                        <div className="flex items-center gap-2">
                                            <Move3d size={16} />
                                            <span className="text-[10px] font-bold uppercase">Mover Pista</span>
                                        </div>
                                        {moveMode === 'track' && <div className="w-2 h-2 rounded-full bg-white animate-pulse"></div>}
                                    </button>
                                    
                                    <button 
                                        onClick={() => { setDecoMode(!decoMode); setMoveMode('none'); speak(decoMode ? "Modo Pista" : "Modo Decoración"); }} 
                                        className={`p-2 rounded transition flex items-center justify-between gap-3 min-w-[130px] ${decoMode ? 'bg-purple-600 text-white shadow' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 hover:text-white'}`}
                                    >
                                        <div className="flex items-center gap-2">
                                            <TreePine size={16} />
                                            <span className="text-[10px] font-bold uppercase">Modo Escenario</span>
                                        </div>
                                        {decoMode && <div className="w-2 h-2 rounded-full bg-white animate-pulse"></div>}
                                    </button>
                                </div>
                                <div className="w-full h-px bg-slate-700 my-0.5"></div>
                                <div className="flex gap-1">
                                    <button onClick={rotateBoard} className="flex-1 p-1.5 rounded transition bg-slate-800 text-slate-300 hover:bg-blue-600 hover:text-white border border-slate-700" title="Girar 90º"><RotateCw size={14} className="mx-auto" /></button>
                                    <button onClick={toggleSystem} className="flex-1 p-1.5 rounded transition bg-slate-800 text-slate-300 hover:bg-indigo-600 hover:text-white border border-slate-700 text-[9px] font-bold" title="Cambiar Sistema">1:32 / 1:24</button>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* --- HUD INFERIOR (PIEZAS O DECORACIÓN) --- */}
                    {viewMode === 'editor' && (
                        <div className={`hud ${appMode === 'racer' ? 'hidden-hud' : ''}`}>
                            {!decoMode ? (
                                /* --- MODO PISTA: Diseño Horizontal Scrollable --- */
                                <>
                                    {/* FILA 1: Piezas Rectas y Herramientas */}
                                    <div className="hud-row">
                                        <div className="flex gap-2 shrink-0">
                                            <button onClick={()=>add('STD')} className="btn-tile" title="Recta Standard"><div className="icon-straight w-6 h-2"></div><span className="btn-label">STD</span></button>
                                            <button onClick={()=>add('CONEX')} className="btn-tile" title="Recta Conexiones"><div className="icon-power"></div><span className="btn-label text-red-400">POW</span></button>
                                            <button onClick={()=>add('HALF')} className="btn-tile" title="Media Recta"><div className="icon-straight w-3 h-2"></div><span className="btn-label">1/2</span></button>
                                            <button onClick={()=>add('QTR')} className="btn-tile" title="Cuarto de Recta"><div className="icon-straight w-2 h-2"></div><span className="btn-label">1/4</span></button>
                                        </div>
                                        
                                        <div className="w-px h-10 bg-slate-600 shrink-0 mx-1"></div>
                                        
                                        <div className="flex gap-2 shrink-0">
                                            <button onClick={()=>add('XO')} className="btn-tile" title="Cruce"><div className="icon-cross"></div><span className="btn-label text-slate-300">CR</span></button>
                                        </div>

                                        <div className="w-px h-10 bg-slate-600 shrink-0 mx-1"></div>

                                        <div className="flex gap-2 shrink-0">
                                            <button onClick={()=>setNextDir(d => d*-1)} className="btn-tile" title="Cambiar dirección siguiente"><ArrowLeftRight size={20} className={nextDir===1?'text-indigo-400':'text-orange-400'}/></button>
                                            <button onClick={flip} className="btn-tile" title="Girar Pieza Seleccionada"><RotateCw size={20} /></button>
                                            <button onClick={del} className="btn-tile border-red-900/50 text-red-400 hover:bg-red-900/20 hover:border-red-500" title="Borrar Seleccionada"><Trash2 size={20} /></button>
                                            <button onClick={undo} className="btn-tile text-yellow-500 hover:text-yellow-400" title="Deshacer Última"><Undo2 size={20} /></button>
                                        </div>
                                    </div>

                                    {/* FILA 2: Curvas */}
                                    <div className="hud-row">
                                        <div className="flex gap-1 shrink-0"><button onClick={()=>add('R1')} className="btn-tile group"><div className="icon-curve r1-css"></div><span className="btn-label text-red-500">R1</span></button><button onClick={()=>add('R1H')} className="btn-tile group w-10"><div className="icon-curve r1-css scale-75 origin-top-left"></div><span className="btn-label text-red-400">½</span></button></div>
                                        <div className="flex gap-1 shrink-0"><button onClick={()=>add('R2')} className="btn-tile group"><div className="icon-curve r2-css"></div><span className="btn-label text-green-500">R2</span></button><button onClick={()=>add('R2H')} className="btn-tile group w-10"><div className="icon-curve r2-css scale-75 origin-top-left"></div><span className="btn-label text-green-400">½</span></button></div>
                                        <button onClick={()=>add('R3')} className="btn-tile group shrink-0"><div className="icon-curve r3-css"></div><span className="btn-label text-yellow-500">R3</span></button>
                                        <button onClick={()=>add('R4')} className="btn-tile group shrink-0"><div className="icon-curve r4-css"></div><span className="btn-label text-blue-500">R4</span></button>
                                        <button onClick={()=>add('R5')} className="btn-tile group shrink-0"><div className="icon-curve r5-css"></div><span className="btn-label text-indigo-500">R5</span></button>
                                    </div>

                                    {/* FILA 3: Gestión de Archivo (Separada y al fondo) */}
                                    <div className="hud-row pt-2 border-t border-slate-700 mt-1" style={{justifyContent: 'space-between'}}>
                                        <div className="flex gap-2 items-center shrink-0">
                                            <button onClick={()=>setShowBoardConfig(true)} className="p-2 bg-slate-800 rounded border border-slate-600 hover:bg-slate-700 text-slate-400 hover:text-white transition shadow"><Ruler size={18}/></button>
                                            
                                            {isSelectionStart && moveMode === 'none' && (
                                                <div className="flex gap-1 items-center bg-blue-900/40 rounded px-1 border border-blue-500/50">
                                                    <span className="text-[9px] font-bold text-blue-300 mr-1">SALIDA</span>
                                                    <button onClick={()=>rotateStart(-5)} className="p-1.5 hover:bg-blue-600 rounded text-blue-300 hover:text-white" title="-5º"><RotateCcw size={16}/></button>
                                                    <button onClick={()=>rotateStart(5)} className="p-1.5 hover:bg-blue-600 rounded text-blue-300 hover:text-white" title="+5º"><RotateCw size={16}/></button>
                                                    <button onClick={()=>rotateStart(90)} className="p-1.5 hover:bg-blue-600 rounded text-blue-300 hover:text-white font-bold text-xs border-l border-blue-700 ml-1 pl-2" title="+90º">90º</button>
                                                </div>
                                            )}

                                            <div className="flex gap-2 px-2 border-l border-r border-slate-600 shrink-0">
                                                <button onClick={()=>spawnParallel('left')} className="btn-new-circuit" title="Crear circuito paralelo a la IZQUIERDA"><CopyPlus size={20} /><span>+ PARALELA</span></button>
                                            </div>

                                            <button onClick={()=>setViewMode('reset_view')} className="p-2 bg-indigo-900 rounded border border-indigo-600 hover:bg-indigo-700 text-indigo-200 hover:text-white transition shadow flex gap-2 font-bold items-center" title="Volver al Centro"><Home size={18}/></button>
                                            <button onClick={reset} className="p-2 bg-slate-900 rounded border border-slate-700 hover:bg-red-900 text-slate-500 hover:text-white transition shadow" title="Reiniciar"><RotateCcw size={18}/></button>
                                        </div>
                                        <div className="flex items-center gap-2 shrink-0 pl-4">
                                            <input type="file" ref={fileInputRef} onChange={loadCircuit} accept=".json" style={{display:'none'}} />
                                            <button onClick={()=>fileInputRef.current.click()} className="p-2 bg-slate-700 hover:bg-slate-600 text-white rounded shadow border-b-2 border-slate-900 active:border-b-0 active:translate-y-0.5" title="Cargar Circuito"><FolderOpen size={18}/></button>
                                            <button onClick={saveCircuit} className="p-2 bg-green-700 hover:bg-green-600 text-white rounded shadow border-b-2 border-green-900 active:border-b-0 active:translate-y-0.5" title="Guardar Circuito"><Save size={18}/></button>
                                            
                                            <button onClick={generateReport} className="flex items-center gap-2 px-4 py-2 rounded bg-red-600 hover:bg-red-700 text-white shadow-lg transition-all font-black text-sm tracking-wide border-b-4 border-red-800 active:border-b-0 active:translate-y-1"><FileText size={18} /> PDF</button>
                                        </div>
                                    </div>
                                </>
                            ) : (
                                /* --- MODO DECORACIÓN --- */
                                <div className="flex flex-col w-full h-full pb-safe">
                                    <div className="flex justify-between items-center px-4 py-2 border-b border-slate-700 bg-slate-900/50">
                                        <div className="flex items-center gap-2 text-purple-400 font-bold uppercase text-xs tracking-wider">
                                            <Trees size={16}/> BIBLIOTECA
                                        </div>
                                        
                                        {/* Acciones para el objeto seleccionado en escena */}
                                        {selectedDecoObject && (
                                            <div className="flex gap-4 items-center animate-fade-in w-full justify-end pb-1 px-4">
                                                
                                                {/* TRANSFORM CONTROLS */}
                                                <div className="flex gap-3 p-1 bg-slate-800/80 rounded-xl border border-slate-600 shadow-xl backdrop-blur-sm">
                                                    {/* ROTATION */}
                                                    <div className="flex gap-1">
                                                        <button onClick={(e)=>{ e.stopPropagation(); updateDecoInstance(selectedDecoObject.instanceId, 'rotation', [selectedDecoObject.rotation[0], selectedDecoObject.rotation[1] - Math.PI/4, selectedDecoObject.rotation[2]]); }} className="w-10 h-10 bg-slate-700 rounded-lg flex items-center justify-center text-white hover:bg-cyan-600 active:scale-95 transition shadow-lg border border-slate-600"><RotateCcw size={20}/></button>
                                                        <button onClick={(e)=>{ e.stopPropagation(); updateDecoInstance(selectedDecoObject.instanceId, 'rotation', [selectedDecoObject.rotation[0], selectedDecoObject.rotation[1] + Math.PI/4, selectedDecoObject.rotation[2]]); }} className="w-10 h-10 bg-slate-700 rounded-lg flex items-center justify-center text-white hover:bg-cyan-600 active:scale-95 transition shadow-lg border border-slate-600"><RotateCw size={20}/></button>
                                                    </div>

                                                    <div className="w-px bg-slate-600 mx-1"></div>

                                                    {/* SCALE */}
                                                    <div className="flex gap-1">
                                                        <button onClick={(e)=>{ e.stopPropagation(); updateDecoInstance(selectedDecoObject.instanceId, 'scale', Math.max(0.1, selectedDecoObject.scale - 0.1)); }} className="w-10 h-10 bg-slate-700 rounded-lg flex items-center justify-center text-white hover:bg-blue-600 active:scale-95 transition shadow-lg border border-slate-600"><Minus size={20}/></button>
                                                        <button onClick={(e)=>{ e.stopPropagation(); updateDecoInstance(selectedDecoObject.instanceId, 'scale', selectedDecoObject.scale + 0.1); }} className="w-10 h-10 bg-slate-700 rounded-lg flex items-center justify-center text-white hover:bg-blue-600 active:scale-95 transition shadow-lg border border-slate-600"><Plus size={20}/></button>
                                                    </div>
                                                </div>

                                                {/* DELETE - Separated */}
                                                <button onClick={deleteDecoInstance} className="w-12 h-12 bg-red-900/80 rounded-xl flex items-center justify-center text-red-200 hover:bg-red-600 hover:text-white hover:shadow-[0_0_15px_rgba(220,38,38,0.5)] active:scale-90 transition border border-red-700 shadow-xl ml-4" title="Borrar Objeto">
                                                    <Trash2 size={24} strokeWidth={2.5} />
                                                </button>
                                            </div>
                                        )}
                                        
                                        {!selectedDecoObject && (
                                            <div className="flex gap-2">
                                                <input type="file" ref={decoObjRef} onChange={handleDecoObjUpload} accept=".obj" className="hidden" />
                                                <button onClick={()=>decoObjRef.current.click()} className="flex items-center gap-1 px-3 py-1 bg-purple-700 hover:bg-purple-600 rounded text-[10px] font-bold text-white transition whitespace-nowrap"><Plus size={12}/> OBJETO .OBJ</button>
                                                
                                                <input type="file" ref={decoMtlRef} onChange={handleDecoMtlUpload} accept=".mtl" className="hidden" />
                                                <button onClick={()=>decoMtlRef.current.click()} className="flex items-center gap-1 px-3 py-1 bg-slate-700 hover:bg-slate-600 rounded text-[10px] font-bold text-white transition whitespace-nowrap"><Upload size={12}/> TEXTURA .MTL</button>
                                            </div>
                                        )}
                                    </div>
                                    
                                    <div className="flex gap-2 overflow-x-auto p-2 scrollbar-hide">
                                        {[...BASE_DECOS, ...customDecos].map(deco => (
                                            <div 
                                                key={deco.id} 
                                                onClick={() => setActiveDecoId(deco.id)}
                                                className={`cursor-pointer flex flex-col items-center p-2 rounded min-w-[80px] border transition relative group ${activeDecoId === deco.id ? 'bg-purple-900/50 border-purple-500 text-white' : 'bg-slate-800 border-slate-700 text-slate-400 hover:bg-slate-700'}`}
                                            >
                                                <button 
                                                    onClick={(e) => { e.stopPropagation(); setPreviewData({ type: 'DECO', obj: deco.customData?.obj, mtl: deco.customData?.mtl, name: deco.name }); }}
                                                    className="absolute top-1 right-1 p-1 bg-black/50 hover:bg-purple-600 rounded-full text-white opacity-0 group-hover:opacity-100 transition-all z-10"
                                                    title="Vista Previa 3D"
                                                >
                                                    <Eye size={10} />
                                                </button>

                                                <div className="w-10 h-10 bg-slate-900 rounded mb-1 flex items-center justify-center pointer-events-none">
                                                    <BoxSelect size={20} className={activeDecoId === deco.id ? 'text-purple-400' : 'text-slate-600'}/>
                                                </div>
                                                <span className="text-[9px] font-bold uppercase truncate w-full text-center pointer-events-none">{deco.name}</span>
                                            </div>
                                        ))}
                                    </div>
                                    <div className="px-4 py-1 text-center">
                                        <span className="text-[10px] text-slate-500 animate-pulse">
                                            {selectedDecoObject ? "Arrastra el objeto para moverlo" : "Haz click sobre el tablero para colocar el objeto seleccionado"}
                                        </span>
                                    </div>
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
